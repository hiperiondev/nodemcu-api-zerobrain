adc = {
    
    force_init_mode = {
        description = "Checks and if necessary reconfigures the ADC mode setting in the ESP init data block."
        syntax = "adc.force_init_mode(mode_value)"
        parameters = "mode_value One of adc.INIT_ADC or adc.INIT_VDD33."
        returns = "True if the function had to change the mode, false if the mode was already configured. On a true return the ESP needs to be restarted for the change to take effect."
        example = "lua , -- in you init.lua: , if adc.force_init_mode(adc.INIT_VDD33) , then ,   node.restart() ,   return -- don't bother continuing, the restart is scheduled , end , print("System voltage (mV):", adc.readvdd33(0)) , "
        seealso = "[node.restart()](node.md#noderestart)"
    }
    
    read = {
        description = "Samples the ADC."
        syntax = "adc.read(channel)"
        parameters = "channel always 0 on the ESP8266"
        returns = "the sampled value (number) , If the ESP8266 has been configured to use the ADC for reading the system voltage, this function will always return 65535. This is a hardware and/or SDK limitation."
        example = "lua , val = adc.read(0)"
    }
    
    readvdd33 = {
        description = "Reads the system voltage."
        syntax = "adc.readvdd33()"
        parameters = "none"
        returns = "system voltage in millivolts (number) , If the ESP8266 has been configured to use the ADC for sampling the external pin, this function will always return 65535. This is a hardware and/or SDK limitation."
    }

}
am2320 = {
    
    init = {
        description = "Initializes the module and sets the pin configuration. Returns model, version, serial but is seams these where all zero on my model."
        syntax = "model, version, serial = am2320.init(sda, scl)"
        parameters = "- sda data pin , - scl clock pin"
        returns = "- model  16 bits number of model , - version  8 bits version number , - serial  32 bits serial number ,    Note: I have only observed values of 0 for all of these, maybe other sensors return more sensible readings."
    }
    
    read = {
        description = "Samples the sensor and returns the relative humidity in % and temperature in celsius, as an integer multiplied with 10."
        syntax = "am2320.read()"
        returns = "- relative humidity percentage multiplied with 10 (integer) , - temperature in celcius multiplied with 10 (integer)"
        example = "lua , am2320.init(1, 2) , rh, t = am2320.read() , print(string.format("RH: %s%%", rh / 10)) , print(string.format("Temperature: %s degrees C", t / 10)) , "
    }

}
apa102 = {
    
    write = {
        description = "Send ABGR data in 8 bits to a APA102 chain."
        syntax = "apa102.write(data_pin, clock_pin, string)"
        parameters = "- data_pin any GPIO pin 0, 1, 2, ... , - clock_pin any GPIO pin 0, 1, 2, ... , - string payload to be sent to one or more APA102 LEDs. ,   It should be composed from a AGRB quadruplet per element. ,     - A1 the first pixel's Intensity channel (0-31) ,     - B1 the first pixel's Blue channel (0-255)<br /> ,     - G1 the first pixel's Green channel (0-255) ,     - R1 the first pixel's Red channel (0-255) ,     ... You can connect a lot of APA102 ... ,     - A2, G2, R2, B2 are the next APA102s Intensity, Blue, Green and channel parameters"
        returns = "nil"
        example = "lua , a = 31 , g = 0 , r = 255 , b = 0 , led_abgr = string.char(a, g, r, b, a, g, r, b)  , apa102.write(2, 3, leds_abgr) -- turn two APA102s to red, connected to data_pin 2 and clock_pin 3 , "
    }

}
bit = {
    
    arshift = {
        description = "Arithmetic right shift a number equivalent to value >> shift in C."
        syntax = "bit.arshift(value, shift)"
        parameters = "- value the value to shift , - shift positions to shift"
        returns = "the number shifted right (arithmetically)"
    }
    
    band = {
        description = "Bitwise AND, equivalent to val1 & val2 & ... & valn in C."
        syntax = "bit.band(val1, val2 [, ... valn])"
        parameters = " - val1 first AND argument ,  - val2 second AND argument ,  - ...valn ...nth AND argument"
        returns = "the bitwise AND of all the arguments (number)"
    }
    
    bit = {
        description = "Generate a number with a 1 bit (used for mask generation). Equivalent to 1 << position in C."
        syntax = "bit.bit(position)"
        parameters = "position position of the bit that will be set to 1"
        returns = "a number with only one 1 bit at position (the rest are set to 0)"
    }
    
    bnot = {
        description = "Bitwise negation, equivalent to ~value in C."
        syntax = "bit.bnot(value)"
        parameters = "value the number to negate"
        returns = "the bitwise negated value of the number"
    }
    
    bor = {
        description = "Bitwise OR, equivalent to val1 | val2 | ... | valn in C."
        syntax = "bit.bor(val1, val2 [, ... valn])"
        parameters = "- val1 first OR argument. , - val2 second OR argument. , - ...valn ...nth OR argument"
        returns = "the bitwise OR of all the arguments (number)"
    }
    
    bxor = {
        description = "Bitwise XOR, equivalent to val1 ^ val2 ^ ... ^ valn in C."
        syntax = "bit.bxor(val1, val2 [, ... valn])"
        parameters = "- val1 first XOR argument , - val2 second XOR argument , - ...valn ...nth XOR argument"
        returns = "the bitwise XOR of all the arguments (number)"
    }
    
    clear = {
        description = "Clear bits in a number."
        syntax = "bit.clear(value, pos1 [, ... posn])"
        parameters = "- value the base number , - pos1 position of the first bit to clear , - ...posn position of thet nth bit to clear"
        returns = "the number with the bit(s) cleared in the given position(s)"
    }
    
    isclear = {
        description = "Test if a given bit is cleared."
        syntax = "bit.isclear(value, position)"
        parameters = "- value the value to test , - position bit position to test"
        returns = "true if the bit at the given position is 0, false othewise"
    }
    
    isset = {
        description = "Test if a given bit is set."
        syntax = "bit.isset(value, position)"
        parameters = "- value the value to test , - position bit position to test"
        returns = "true if the bit at the given position is 1, false otherwise"
    }
    
    lshift = {
        description = "Left-shift a number, equivalent to value << shift in C."
        syntax = "bit.lshift(value, shift)"
        parameters = "- value the value to shift , - shift positions to shift"
        returns = "the number shifted left"
    }
    
    rshift = {
        description = "Logical right shift a number, equivalent to ( unsigned )value >> shift in C."
        syntax = "bit.rshift(value, shift)"
        parameters = "- value the value to shift. , - shift positions to shift."
        returns = "the number shifted right (logically)"
    }
    
    set = {
        description = "Set bits in a number."
        syntax = "bit.set(value, pos1 [, ... posn ])"
        parameters = "- value the base number. , - pos1 position of the first bit to set. , - ...posn position of the nth bit to set."
        returns = "the number with the bit(s) set in the given position(s)"
    }

}
bme280 = {
    
    altitude = {
        description = "For given air pressure and sea level air pressure returns the altitude in meters as an integer multiplied with 100, i.e. altimeter function."
        syntax = "bme280.altitude(P, QNH)"
        parameters = "- P measured pressure , - QNH current sea level pressure"
        returns = "altitude in meters of measurement point"
    }
    
    baro = {
        description = "Reads the sensor and returns the air temperature in hectopascals as an integer multiplied with 1000 or nil when readout is not successful. , Current temperature is needed to calculate the air pressure so temperature reading is performed prior reading pressure data. Second returned variable is therefore current temperature."
        syntax = "bme280.baro()"
        parameters = "none"
        returns = "- P air pressure in hectopascals multiplied by 1000 , - T temperature in celsius as an integer multiplied with 100"
    }
    
    dewpoint = {
        description = "For given temperature and relative humidity returns the dew point in celsius as an integer multiplied with 100."
        syntax = "bme280.dewpoint(H, T)"
        parameters = "- H relative humidity in percent multiplied by 1000. , - T temperate in celsius multiplied by 100."
        returns = "dew point in celsisus"
    }
    
    humi = {
        description = "Reads the sensor and returns the air relative humidity in percents as an integer multiplied with 100 or nil when readout is not successful. , Current temperature is needed to calculate the relative humidity so temperature reading is performed prior reading pressure data. Second returned variable is therefore current temperature."
        syntax = "bme280.humi()"
        parameters = "none"
        returns = "- H last relative humidity reading in % times 1000 , - T temperature in celsius as an integer multiplied with 100"
    }
    
    init = {
        description = "Initializes module. Initialization is mandatory before read values."
        syntax = "bme280.init(sda, scl, [temp_oss, press_oss, humi_oss, power_mode, inactive_duration, IIR_filter])"
        parameters = "- sda - SDA pin   , - scl - SCL pin , - (optional) temp_oss - Controls oversampling of temperature data. Default oversampling is 16x. , - (optional) press_oss - Controls oversampling of pressure data. Default oversampling is 16x. , - (optional) humi_oss - Controls oversampling of humidity data. Default oversampling is 16x , - (optional) sensor_mode - Controls the sensor mode of the device. Default sensor more is normal. , - (optional) inactive_duration - Controls inactive duration in normal mode. Default inactive duration is 20ms. , - (optional) IIR_filter - Controls the time constant of the IIR filter. Default fitler coefficient is 16. , |temp_oss, press_oss, humi_oss|Data oversampling| , |-----|-----------------| , |0|Skipped (output set to 0x80000)| , |1|oversampling ×1| , |2|oversampling ×2| , |3|oversampling ×4| , |4|oversampling ×8| , |**5**|**oversampling ×16**| , |sensor_mode|Sensor mode| , |-----|-----------------| , |0|Sleep mode| , |1 and 2|Forced mode| , |**3**|**Normal mode**| , Using forced mode is recommended for applications which require low sampling rate or hostbased synchronization. The sensor enters into sleep mode after a forced readout. Please refer to BME280 Final Datasheet for more details. , |inactive_duration|t standby (ms)| , |-----|-----------------| , |0|0.5| , |1|62.5|  , |2|125| , |3|250| , |4|500| , |5|1000|  , |6|10| , |**7**|**20**| , |IIR_filter|Filter coefficient | , |-----|-----------------| , |0|Filter off| , |1|2| , |2|4| , |3|8| , |**4**|**16**|"
        returns = "nil if initialization has failed (no sensor connected?), 2 if sensor is BME280, 1 if sensor is BMP280"
        example = "lua , alt=320 -- altitude of the measurement place , bme280.init(3, 4) , P, T = bme280.baro() , print(string.format("QFE=%d.%03d", P/1000, P%1000)) , -- convert measure air pressure to sea level pressure , QNH = bme280.qfe2qnh(P, alt) , print(string.format("QNH=%d.%03d", QNH/1000, QNH%1000)) , H, T = bme280.humi() , print(string.format("T=%d.%02d", T/100, T%100)) , print(string.format("humidity=%d.%03d%%", H/1000, H%1000)) , D = bme280.dewpoint(H, T) , print(string.format("dew_point=%d.%02d", D/100, D%100)) , -- altimeter function - calculate altitude based on current sea level pressure (QNH) and measure pressure , P = bme280.baro() , curAlt = bme280.altitude(P, QNH) , print(string.format("altitude=%d.%02d", curAlt/100, curAlt%100)) ,  , Use bme280.init(sda, scl, 1, 3, 0, 3, 0, 4) for "game mode" - Oversampling settings  pressure ×4, temperature ×1, humidity ×0, sensor mode: normal mode, inactive duration  = 0.5 ms, IIR filter settings  filter coefficient 16. , Example of readout in forced mode (asynchronous) , lua , bme280.init(3, 4, nil, nil, nil, 0) -- initialize to sleep mode , bme280.startreadout(0, function () ,   T = bme280.temp() ,   print(string.format("T=%d.%02d", T/100, T%100)) , end)"
    }
    
    qfe2qnh = {
        description = "For given altitude converts the air pressure to sea level air pressure."
        syntax = "bme280.qfe2qnh(P, altitude)"
        parameters = "- P measured pressure , - altitude altitude in meters of measurement point"
        returns = "sea level pressure"
    }
    
    startreadout = {
        description = "Starts readout (turns the sensor into forced mode). After the readout the sensor turns to sleep mode."
        syntax = "bme280.startreadout(delay, callback)"
        parameters = "- delay sets sensor to forced mode and calls the callback (if provided) after given number of milliseconds. For 0 the default delay is set to 113ms (sufficient time to perform reading for oversampling settings 16x). For different oversampling setting please refer to [BME280 Final Datasheet - Appendix B: Measurement time and current calculation](http://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BME280_DS001-11.pdf#page=51). , - callback if provided it will be invoked after given delay. The sensor reading should be finalized by then so."
        returns = "nil"
    }
    
    temp = {
        description = "Reads the sensor and returns the temperature in celsius as an integer multiplied with 100."
        syntax = "bme280.temp()"
        parameters = "none"
        returns = "- T temperature in celsius as an integer multiplied with 100 or nil when readout is not successful , - t_fine temperature measure used in pressure and humidity compensation formulas (generally no need to use this value)"
    }

}
bmp085 = {
    
    init = {
        description = "Initializes the module and sets the pin configuration."
        syntax = "bmp085.init(sda, scl)"
        parameters = "- sda data pin , - scl clock pin"
        returns = "nil"
    }
    
    temperature = {
        description = "Samples the sensor and returns the temperature in celsius as an integer multiplied with 10."
        syntax = "bmp085.temperature()"
        returns = "temperature multiplied with 10 (integer)"
        example = "lua , bmp085.init(1, 2) , local t = bmp085.temperature() , print(string.format("Temperature: %s.%s degrees C", t / 10, t % 10))"
    }
    
    pressure = {
        description = "Samples the sensor and returns the pressure in pascal as an integer. , The optional oversampling_setting parameter determines for how long time the sensor samples data. , The default is 3 which is the longest sampling setting. Possible values are 0, 1, 2, 3. , See the data sheet for more information."
        syntax = "bmp085.pressure(oversampling_setting)"
        parameters = "oversampling_setting integer that can be 0, 1, 2 or 3"
        returns = "pressure in pascals (integer)"
        example = "lua , bmp085.init(1, 2) , local p = bmp085.pressure() , print(string.format("Pressure: %s.%s mbar", p / 100, p % 100))"
    }
    
    pressure_raw = {
        description = "Samples the sensor and returns the raw pressure in internal units. Might be useful if you need higher precision."
        syntax = "bmp085.pressure_raw(oversampling_setting)"
        parameters = "oversampling_setting integer that can be 0, 1, 2 or 3"
        returns = "raw pressure sampling value (integer)"
    }

}
cjson = {
    
    encode = {
        description = "Encode a Lua table to a JSON string. For details see the [documentation of the original Lua library](http://kyne.com.au/~mark/software/lua-cjson-manual.html#encode)."
        syntax = "cjson.encode(table)"
        parameters = "table data to encode , While it also is possible to encode plain strings and numbers rather than a table, it is not particularly useful to do so."
        returns = "JSON string"
        example = "lua , ok, json = pcall(cjson.encode, {key="value"}) , if ok then ,   print(json) , else ,   print("failed to encode!") , end"
    }
    
    decode = {
        description = "Decode a JSON string to a Lua table. For details see the [documentation of the original Lua library](http://kyne.com.au/~mark/software/lua-cjson-manual.html#_decode)."
        syntax = "cjson.decode(str)"
        parameters = "str JSON string to decode"
        returns = "Lua table representation of the JSON data"
        example = "lua , t = cjson.decode('{"key":"value"}') , for k,v in pairs(t) do print(k,v) end , "
    }

}
coap = {
    
    Client = {
        description = "Creates a CoAP client."
        syntax = "coap.Client()"
        parameters = "none"
        returns = "CoAP client"
        example = "lua , cc = coap.Client() , -- assume there is a coap server at ip 192.168.100 , cc:get(coap.CON, "coap://192.168.18.100:5683/.well-known/core") , -- GET is not complete, the result/payload only print out in console. , cc:post(coap.NON, "coap://192.168.18.100:5683/", "Hello")"
    }
    
    Server = {
        description = "Creates a CoAP server."
        syntax = "coap.Server()"
        parameters = "none"
        returns = "CoAP server"
        example = "lua , -- use copper addon for firefox , cs=coap.Server() , cs:listen(5683) , myvar=1 , cs:var("myvar") -- get coap://192.168.18.103:5683/v1/v/myvar will return the value of myvar: 1 , all='[1,2,3]' , cs:var("all", coap.JSON) -- sets content type to json , -- function should tack one string, return one string. , function myfun(payload) ,   print("myfun called") ,   respond = "hello" ,   return respond , end , cs:func("myfun") -- post coap://192.168.18.103:5683/v1/f/myfun will call myfun ,  , ####CoAP Client"
    }
    
    client:get = {
        description = "Issues a GET request to the server."
        syntax = "coap.client:get(type, uri[, payload])"
        parameters = "- type coap.CON, coap.NON, defaults to CON. If the type is CON and request fails, the library retries four more times before giving up. , - uri the URI such as "coap://192.168.18.103:5683/v1/v/myvar", only IP addresses are supported i.e. no hostname resoltion. , - payload optional, the payload will be put in the payload section of the request."
        returns = "nil"
    }
    
    client:put = {
        description = "Issues a PUT request to the server."
        syntax = "coap.client:put(type, uri[, payload])"
        parameters = "- type coap.CON, coap.NON, defaults to CON. If the type is CON and request fails, the library retries four more times before giving up. , - uri the URI such as "coap://192.168.18.103:5683/v1/v/myvar", only IP addresses are supported i.e. no hostname resoltion. , - payload optional, the payload will be put in the payload section of the request."
        returns = "nil"
    }
    
    client:post = {
        description = "Issues a POST request to the server."
        syntax = "coap.client:post(type, uri[, payload])"
        parameters = "- type coap.CON, coap.NON, defaults to CON. when type is CON, and request failed, the request will retry another 4 times before giving up. , - uri the uri such as coap://192.168.18.103:5683/v1/v/myvar, only IP is supported. , - payload optional, the payload will be put in the payload section of the request."
        returns = "nil"
    }
    
    client:delete = {
        description = "Issues a DELETE request to the server."
        syntax = "coap.client:delete(type, uri[, payload])"
        parameters = "- type coap.CON, coap.NON, defaults to CON. If the type is CON and request fails, the library retries four more times before giving up. , - uri the URI such as "coap://192.168.18.103:5683/v1/v/myvar", only IP addresses are supported i.e. no hostname resoltion. , - payload optional, the payload will be put in the payload section of the request."
        returns = "nil , ####CoAP Server"
    }
    
    server:listen = {
        description = "Starts the CoAP server on the given port."
        syntax = "coap.server:listen(port[, ip])"
        parameters = "- port server port (number) , - ip optional IP address"
        returns = "nil"
    }
    
    server:close = {
        description = "Closes the CoAP server."
        syntax = "coap.server:close()"
        parameters = "none"
        returns = "nil"
    }
    
    server:var = {
        description = "Registers a Lua variable as an endpoint in the server. the variable value then can be retrieved by a client via GET method, represented as an [URI](http://tools.ietf.org/html/rfc7252#section-6) to the client. The endpoint path for varialble is '/v1/v/'."
        syntax = "coap.server:var(name[, content_type])"
        parameters = "- name the Lua variable's name , - content_type optional, defaults to coap.TEXT_PLAIN, see [Content Negotiation](http://tools.ietf.org/html/rfc7252#section-5.5.4)"
        returns = "nil"
        example = "lua , -- use copper addon for firefox , cs=coap.Server() , cs:listen(5683) , myvar=1 , cs:var("myvar") -- get coap://192.168.18.103:5683/v1/v/myvar will return the value of myvar: 1 , -- cs:var(myvar), WRONG, this api accept the name string of the varialbe. but not the variable itself. , all='[1,2,3]' , cs:var("all", coap.JSON) -- sets content type to json"
    }
    
    server:func = {
        description = "Registers a Lua function as an endpoint in the server. The function then can be called by a client via POST method. represented as an [URI](http://tools.ietf.org/html/rfc7252#section-6) to the client. The endpoint path for function is '/v1/f/'.  , When the client issues a POST request to this URI, the payload will be passed to the function as parameter. The function's return value will be the payload in the message to the client. , The function registered SHOULD accept ONLY ONE string type parameter, and return ONE string value or return nothing."
        syntax = "coap.server:func(name[, content_type])"
        parameters = "- name the Lua function's name , - content_type optional, defaults to coap.TEXT_PLAIN, see [Content Negotiation](http://tools.ietf.org/html/rfc7252#section-5.5.4)"
        returns = "nil"
        example = "lua , -- use copper addon for firefox , cs=coap.Server() , cs:listen(5683) , -- function should take only one string, return one string. , function myfun(payload) ,   print("myfun called") ,   respond = "hello" ,   return respond , end , cs:func("myfun") -- post coap://192.168.18.103:5683/v1/f/myfun will call myfun , -- cs:func(myfun), WRONG, this api accept the name string of the function. but not the function itself. , "
    }

}
crypto = {
    
    encrypt = {
        description = "Encrypts Lua strings."
        syntax = "crypto.encrypt(algo, key, plain [, iv])"
        parameters = "  - algo the name of the encryption algorithm to use, one of ,     - "AES-ECB" for 128-bit AES in ECB mode ,     - "AES-CBC" for 128-bit AES in CBC mode ,   - key the encryption key as a string; for AES encryption this *MUST* be 16 bytes long ,   - plain the string to encrypt; it will be automatically zero-padded to a 16-byte boundary if necessary ,   - iv the initilization vector, if using AES-CBC; defaults to all-zero if not given"
        returns = "The encrypted data as a binary string. For AES this is always a multiple of 16 bytes in length."
        example = "lua , print(crypto.toHex(crypto.encrypt("AES-ECB", "1234567890abcdef", "Hi, I'm secret!"))) , "
        seealso = "  - [crypto.decrypt()](#cryptodecrypt)"
    }
    
    decrypt = {
        description = "Decrypts previously encrypted data."
        syntax = "crypto.decrypt(algo, key, cipher [, iv])"
        parameters = "  - algo the name of the encryption algorithm to use, one of ,     - "AES-ECB" for 128-bit AES in ECB mode ,     - "AES-CBC" for 128-bit AES in CBC mode ,   - key the encryption key as a string; for AES encryption this *MUST* be 16 bytes long ,   - cipher the cipher text to decrypt (as obtained from crypto.encrypt()) ,   - iv the initilization vector, if using AES-CBC; defaults to all-zero if not given"
        returns = "The decrypted string. , Note that the decrypted string may contain extra zero-bytes of padding at the end. One way of stripping such padding is to use :match("(.-)%z*$") on the decrypted string. Additional care needs to be taken if working on binary data, in which case the real length likely needs to be encoded with the data, and at which point :sub(1, n) can be used to strip the padding."
        example = "lua , key = "1234567890abcdef" , cipher = crypto.encrypt("AES-ECB", key, "Hi, I'm secret!") , print(crypto.toHex(cipher)) , print(crypto.decrypt("AES-ECB", key, cipher)) , "
        seealso = "  - [crypto.encrypt()](#cryptoencrypt)"
    }
    
    fhash = {
        description = "Compute a cryptographic hash of a a file."
        syntax = "hash = crypto.fhash(algo, filename)"
        parameters = "- algo the hash algorithm to use, case insensitive string , - filename the path to the file to hash , Supported hash algorithms are: , - MD2 (not available by default, has to be explicitly enabled in app/include/user_config.h) , - MD5 , - SHA1 , - SHA256, SHA384, SHA512 (unless disabled in app/include/user_config.h)"
        returns = "A binary string containing the message digest. To obtain the textual version (ASCII hex characters), please use [crypto.toHex()](#cryptotohex )."
        example = "lua , print(crypto.toHex(crypto.fhash("sha1","myfile.lua")))"
    }
    
    hash = {
        description = "Compute a cryptographic hash of a Lua string."
        syntax = "hash = crypto.hash(algo, str)"
        parameters = "algo the hash algorithm to use, case insensitive string , str string to hash contents of , Supported hash algorithms are: , - MD2 (not available by default, has to be explicitly enabled in app/include/user_config.h) , - MD5 , - SHA1 , - SHA256, SHA384, SHA512 (unless disabled in app/include/user_config.h)"
        returns = "A binary string containing the message digest. To obtain the textual version (ASCII hex characters), please use [crypto.toHex()](#cryptotohex	)."
        example = "lua , print(crypto.toHex(crypto.hash("sha1","abc")))"
    }
    
    new_hash = {
        description = "Create a digest/hash object that can have any number of strings added to it. Object has update and finalize functions."
        syntax = "hashobj = crypto.new_hash(algo)"
        parameters = "algo the hash algorithm to use, case insensitive string , Supported hash algorithms are: , - MD2 (not available by default, has to be explicitly enabled in app/include/user_config.h) , - MD5 , - SHA1 , - SHA256, SHA384, SHA512 (unless disabled in app/include/user_config.h)"
        returns = "Userdata object with update and finalize functions available."
        example = "lua , hashobj = crypto.new_hash("SHA1") , hashobj:update("FirstString")) , hashobj:update("SecondString")) , digest = hashobj:finalize() , print(crypto.toHex(digest))"
    }
    
    hmac = {
        description = "Compute a [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code) (Hashed Message Authentication Code) signature for a Lua string."
        syntax = "signature = crypto.hmac(algo, str, key)"
        parameters = "- algo hash algorithm to use, case insensitive string , - str data to calculate the hash for , - key key to use for signing, may be a binary string , Supported hash algorithms are: , - MD2 (not available by default, has to be explicitly enabled in app/include/user_config.h) , - MD5 , - SHA1 , - SHA256, SHA384, SHA512 (unless disabled in app/include/user_config.h)"
        returns = "A binary string containing the HMAC signature. Use [crypto.toHex()](#cryptotohex	) to obtain the textual version."
        example = "lua , print(crypto.toHex(crypto.hmac("sha1","abc","mysecret")))"
    }
    
    mask = {
        description = "Applies an XOR mask to a Lua string. Note that this is not a proper cryptographic mechanism, but some protocols may use it nevertheless."
        syntax = "crypto.mask(message, mask)"
        parameters = "- message message to mask , - mask the mask to apply, repeated if shorter than the message"
        returns = "The masked message, as a binary string. Use [crypto.toHex()](#cryptotohex) to get a textual representation of it."
        example = "lua , print(crypto.toHex(crypto.mask("some message to obscure","X0Y7")))"
    }
    
    toBase64 = {
        description = "Provides a Base64 representation of a (binary) Lua string."
        syntax = "b64 = crypto.toBase64(binary)"
        parameters = "binary input string to Base64 encode , #####Return , A Base64 encoded string."
        example = "lua , print(crypto.toBase64(crypto.hash("sha1","abc")))"
    }
    
    toHex = {
        description = "Provides an ASCII hex representation of a (binary) Lua string. Each byte in the input string is represented as two hex characters in the output."
        syntax = "hexstr = crypto.toHex(binary)"
        parameters = "binary input string to get hex representation for"
        returns = "An ASCII hex string."
        example = "lua , print(crypto.toHex(crypto.hash("sha1","abc"))) , "
    }

}
dht = {
    
    read = {
        description = "Read all kinds of DHT sensors, including DHT11, 21, 22, 33, 44 humidity temperature combo sensor."
        syntax = "dht.read(pin)"
        parameters = "pin pin number of DHT sensor (can't be 0), type is number"
        returns = "- status as defined in Constants , - temp temperature (see note below) , - humi humidity (see note below) , - temp_dec temperature decimal , - humi_dec humidity decimal , !!! note "Note:" ,     If using float firmware then temp and humi are floating point numbers. On an integer firmware, the final values have to be concatenated from temp and temp_dec / humi and hum_dec."
        example = "lua , pin = 5 , status, temp, humi, temp_dec, humi_dec = dht.read(pin) , if status == dht.OK then ,     -- Integer firmware using this example ,     print(string.format("DHT Temperature:%d.%03d;Humidity:%d.%03d\r\n", ,           math.floor(temp), ,           temp_dec, ,           math.floor(humi), ,           humi_dec ,     )) ,     -- Float firmware using this example ,     print("DHT Temperature:"..temp..";".."Humidity:"..humi) , elseif status == dht.ERROR_CHECKSUM then ,     print( "DHT Checksum error." ) , elseif status == dht.ERROR_TIMEOUT then ,     print( "DHT timed out." ) , end"
    }
    
    read11 = {
        description = "Read DHT11 humidity temperature combo sensor."
        syntax = "dht.read11(pin)"
        parameters = "pin pin number of DHT11 sensor (can't be 0), type is number"
        returns = "- status as defined in Constants , - temp temperature (see note below) , - humi humidity (see note below) , - temp_dec temperature decimal , - humi_dec humidity decimal , !!! note "Note:" ,     If using float firmware then temp and humi are floating point numbers. On an integer firmware, the final values have to be concatenated from temp and temp_dec / humi and hum_dec."
        seealso = "[dht.read()](#dhtread)"
    }
    
    readxx = {
        description = "Read all kinds of DHT sensors, except DHT11."
        syntax = "dht.readxx(pin)"
        parameters = "pin pin number of DHT sensor (can't be 0), type is number"
        returns = "- status as defined in Constants , - temp temperature (see note below) , - humi humidity (see note below) , - temp_dec temperature decimal , - humi_dec humidity decimal , !!! note "Note:" ,     If using float firmware then temp and humi are floating point numbers. On an integer firmware, the final values have to be concatenated from temp and temp_dec / humi and hum_dec."
        seealso = "[dht.read()](#dhtread)"
    }

}
encoder = {
    
    toBase64 = {
        description = "Provides a Base64 representation of a (binary) Lua string."
        syntax = "b64 = encoder.toBase64(binary)"
        parameters = "binary input string to Base64 encode , #####Return , A Base64 encoded string."
        example = "lua , print(encoder.toBase64(crypto.hash("sha1","abc")))"
    }
    
    fromBase64 = {
        description = "Decodes a Base64 representation of a (binary) Lua string back into the original string.  An error is , thrown if the string is not a valid base64 encoding."
        syntax = "binary_string = encoder.toBase64(b64)"
        parameters = "b64 Base64 encoded input string  , #####Return , The decoded Lua (binary) string."
        example = "lua , print(encoder.fromBase64(encoder.toBase64("hello world")))"
    }
    
    toHex = {
        description = "Provides an ASCII hex representation of a (binary) Lua string. Each byte in the input string is , represented as two hex characters in the output."
        syntax = "hexstr = encoder.toHex(binary)"
        parameters = "binary input string to get hex representation for"
        returns = "An ASCII hex string."
        example = "lua , print(encoder.toHex(crypto.hash("sha1","abc")))"
    }
    
    fromHex = {
        description = "Returns the Lua binary string decode of a ASCII hex string. Each byte in the output string is , represented as two hex characters in the input.  An error is thrown if the string is not a  , valid base64 encoding."
        syntax = "binary = encoder.fromHex(hexstr)"
        parameters = "hexstr  An ASCII hex string."
        returns = "Decoded string of hex representation."
        example = "lua , print(encoder.fromHex("6a6a6a"))) , "
    }

}
enduser-setup = {
    
    manual = {
        description = "Controls whether manual AP configuration is used. , By default the enduser_setup module automatically configures an open access point when starting, and stops it when the device has been successfully joined to a WiFi network. If manual mode has been enabled, neither of this is done. The device must be manually configured for wifi.SOFTAP mode prior to calling enduser_setup.start(). Additionally, the portal is not stopped after the device has successfully joined to a WiFi network."
        syntax = "enduser_setup.manual([on_off])"
        parameters = "  - on_off a boolean value indicating whether to use manual mode; if not given, the function only returns the current setting."
        returns = "The current setting, true if manual mode is enabled, false if it is not."
        example = "lua , wifi.setmode(wifi.STATIONAP) , wifi.ap.config({ssid="MyPersonalSSID",auth=wifi.AUTH_OPEN}) , enduser_setup.manual(true) , enduser_setup.start( ,   function() ,     print("Connected to wifi as:" .. wifi.sta.getip()) ,   end, ,   function(err, str) ,     print("enduser_setup: Err #" .. err .. ": " .. str) ,   end , );"
    }
    
    start = {
        description = "Starts the captive portal."
        syntax = "enduser_setup.start([onConnected()], [onError(err_num, string)], [onDebug(string)])"
        parameters = " - onConnected() callback will be fired when an IP-address has been obtained, just before the enduser_setup module will terminate itself ,  - onError() callback will be fired if an error is encountered. err_num is a number describing the error, and string contains a description of the error. ,  - onDebug() callback is disabled by default. It is intended to be used to find internal issues in the module. string contains a description of what is going on."
        returns = "nil"
        example = "lua , enduser_setup.start( ,   function() ,     print("Connected to wifi as:" .. wifi.sta.getip()) ,   end, ,   function(err, str) ,     print("enduser_setup: Err #" .. err .. ": " .. str) ,   end , );"
    }
    
    stop = {
        description = "Stops the captive portal."
        syntax = "enduser_setup.stop()"
        parameters = "none"
        returns = "nil"
    }

}
file = {
    
    close = {
        description = "Closes the open file, if any."
        syntax = "file.close()"
        parameters = "none"
        returns = "nil"
        example = "lua , -- open 'init.lua', print the first line. , file.open("init.lua", "r") , print(file.readline()) , file.close() , "
        seealso = "[file.open()](#fileopen)"
    }
    
    exists = {
        description = "Determines whether the specified file exists."
        syntax = "file.exists(filename)"
        parameters = "- filename file to check"
        returns = "true of the file exists (even if 0 bytes in size), and false if it does not exist"
        example = "lua , files = file.list() , if files["device.config"] then ,     print("Config file exists") , end , if file.exists("device.config") then ,     print("Config file exists") , end , "
        seealso = "[file.list()](#filelist)"
    }
    
    flush = {
        description = "Flushes any pending writes to the file system, ensuring no data is lost on a restart. Closing the open file using [file.close()](#fileclose) performs an implicit flush as well."
        syntax = "file.flush()"
        parameters = "none"
        returns = "nil"
        example = "lua , -- open 'init.lua' in 'a+' mode , file.open("init.lua", "a+") , -- write 'foo bar' to the end of the file , file.write('foo bar') , file.flush() , -- write 'baz' too , file.write('baz') , file.close() , "
        seealso = "[file.close()](#fileclose)"
    }
    
    format = {
        description = "Format the file system. Completely erases any existing file system and writes a new one. Depending on the size of the flash chip in the ESP, this may take several seconds."
        syntax = "file.format()"
        parameters = "none"
        returns = "nil"
        seealso = "[file.remove()](#fileremove)"
    }
    
    fscfg = {
        description = "Returns the flash address and physical size of the file system area, in bytes."
        syntax = "file.fscfg()"
        parameters = "none"
        returns = "- flash address (number) , - size (number)"
        example = "lua , print(string.format("0x%x", file.fscfg()))"
    }
    
    fsinfo = {
        description = "Return size information for the file system, in bytes."
        syntax = "file.fsinfo()"
        parameters = "none"
        returns = "- remaining (number) , - used      (number) , - total     (number)"
        example = "lua , -- get file system info , remaining, used, total=file.fsinfo() , print("\nFile system info:\nTotal : "..total.." Bytes\nUsed : "..used.." Bytes\nRemain: "..remaining.." Bytes\n")"
    }
    
    list = {
        description = "Lists all files in the file system."
        syntax = "file.list()"
        parameters = "none"
        returns = "a lua table which contains the {file name: file size} pairs"
        example = "lua , l = file.list(); , for k,v in pairs(l) do ,   print("name:"..k..", size:"..v) , end"
    }
    
    open = {
        description = "Opens a file for access, potentially creating it (for write modes). , When done with the file, it must be closed using file.close()."
        syntax = "file.open(filename, mode)"
        parameters = "- filename file to be opened, directories are not supported , - mode: ,     - "r": read mode (the default) ,     - "w": write mode ,     - "a": append mode ,     - "r+": update mode, all previous data is preserved ,     - "w+": update mode, all previous data is erased ,     - "a+": append update mode, previous data is preserved, writing is only allowed at the end of file"
        returns = "nil if file not opened, or not exists (read modes).  true if file opened ok."
        example = "lua , -- open 'init.lua', print the first line. , file.open("init.lua", "r") , print(file.readline()) , file.close() , "
        seealso = "- [file.close()](#fileclose) , - [file.readline()](#filereadline)"
    }
    
    read = {
        description = "Read content from the open file."
        syntax = "file.read([n_or_str])"
        parameters = "- n_or_str: , 	- if nothing passed in, read up to LUAL_BUFFERSIZE bytes (default 1024) or the entire file (whichever is smaller) , 	- if passed a number n, then read the file until the lesser of n bytes, LUAL_BUFFERSIZE bytes, or EOF is reached. Specifying a number larger than the buffer size will read the buffer size. , 	- if passed a string str, then read until str appears next in the file, LUAL_BUFFERSIZE bytes have been read, or EOF is reached"
        returns = "File content as a string, or nil when EOF"
        example = "lua , -- print the first line of 'init.lua' , file.open("init.lua", "r") , print(file.read('\n')) , file.close() , -- print the first 5 bytes of 'init.lua' , file.open("init.lua", "r") , print(file.read(5)) , file.close() , "
        seealso = "- [file.open()](#fileopen) , - [file.readline()](#filereadline)"
    }
    
    readline = {
        description = "Read the next line from the open file. Lines are defined as zero or more bytes ending with a EOL ('\n') byte. If the next line is longer than LUAL_BUFFERSIZE, this function only returns the first LUAL_BUFFERSIZE bytes (this is 1024 bytes by default)."
        syntax = "file.readline()"
        parameters = "none"
        returns = "File content in string, line by line, including EOL('\n'). Return nil when EOF."
        example = "lua , -- print the first line of 'init.lua' , file.open("init.lua", "r") , print(file.readline()) , file.close() , "
        seealso = "- [file.open()](#fileopen) , - [file.close()](#fileclose) , - [file.read()](#filereade)"
    }
    
    remove = {
        description = "Remove a file from the file system. The file must not be currently open. , ###Syntax , file.remove(filename)"
        parameters = "filename file to remove"
        returns = "nil"
        example = "lua , -- remove "foo.lua" from file system. , file.remove("foo.lua") , "
        seealso = "[file.open()](#fileopen)"
    }
    
    rename = {
        description = "Renames a file. If a file is currently open, it will be closed first."
        syntax = "file.rename(oldname, newname)"
        parameters = "- oldname old file name , - newname new file name"
        returns = "true on success, false on error."
        example = "lua , -- rename file 'temp.lua' to 'init.lua'. , file.rename("temp.lua","init.lua")"
    }
    
    seek = {
        description = "Sets and gets the file position, measured from the beginning of the file, to the position given by offset plus a base specified by the string whence."
        syntax = "file.seek([whence [, offset]])"
        parameters = "- whence , 	- "set": base is position 0 (beginning of the file) , 	- "cur": base is current position (default value) , 	- "end": base is end of file , - offset default 0 , If no parameters are given, the function simply returns the current file offset."
        returns = "the resulting file position, or nil on error"
        example = "lua , file.open("init.lua", "r") , -- skip the first 5 bytes of the file , file.seek("set", 5) , print(file.readline()) , file.close() , "
        seealso = "[file.open()](#fileopen)"
    }
    
    write = {
        description = "Write a string to the open file."
        syntax = "file.write(string)"
        parameters = "string content to be write to file"
        returns = "true if the write is ok, nil on error"
        example = "lua , -- open 'init.lua' in 'a+' mode , file.open("init.lua", "a+") , -- write 'foo bar' to the end of the file , file.write('foo bar') , file.close() , "
        seealso = "- [file.open()](#fileopen) , - [file.writeline()](#filewriteline)"
    }
    
    writeline = {
        description = "Write a string to the open file and append '\n' at the end."
        syntax = "file.writeline(string)"
        parameters = "string content to be write to file"
        returns = "true if write ok, nil on error"
        example = "lua , -- open 'init.lua' in 'a+' mode , file.open("init.lua", "a+") , -- write 'foo bar' to the end of the file , file.writeline('foo bar') , file.close() , "
        seealso = "- [file.open()](#fileopen) , - [file.readline()](#filereadline)"
    }

}
gpio = {
    
    mode = {
        description = "Initialize pin to GPIO mode, set the pin in/out direction, and optional internal weak pull-up."
        syntax = "gpio.mode(pin, mode [, pullup])"
        parameters = "- pin pin to configure, IO index , - mode one of gpio.OUTPUT, gpio.OPENDRAIN, gpio.INPUT, or gpio.INT (interrupt mode) , - pullup gpio.PULLUP enables the weak pull-up resistor; default is gpio.FLOAT"
        returns = "nil"
        example = "lua , gpio.mode(0, gpio.OUTPUT) , "
        seealso = "- [gpio.read()](#gpioread) , - [gpio.write()](#gpiowrite)"
    }
    
    read = {
        description = "Read digital GPIO pin value."
        syntax = "gpio.read(pin)"
        parameters = "pin pin to read, IO index"
        returns = "a number, 0 = low, 1 = high"
        example = "lua , -- read value of gpio 0. , gpio.read(0) , "
        seealso = "[gpio.mode()](#gpiomode)"
    }
    
    serout = {
        description = "Serialize output based on a sequence of delay-times. After each delay, the pin is toggled."
        syntax = "gpio.serout(pin, start_level, delay_times [, repeat_num])"
        parameters = "- pin  pin to use, IO index , - start_level level to start on, either gpio.HIGH or gpio.LOW , - delay_times an array of delay times between each toggle of the gpio pin. , - repeat_num an optional number of times to run through the sequence. , Note that this function blocks, and as such any use of it must adhere to the SDK guidelines of time spent blocking the stack (10-100ms). Failure to do so may lead to WiFi issues or outright crashes/reboots."
        returns = "nil"
        example = "lua , gpio.mode(1,gpio.OUTPUT,gpio.PULLUP) , gpio.serout(1,1,{30,30,60,60,30,30})  -- serial one byte, b10110010 , gpio.serout(1,1,{30,70},8)  -- serial 30% pwm 10k, lasts 8 cycles , gpio.serout(1,1,{3,7},8)  -- serial 30% pwm 100k, lasts 8 cycles , gpio.serout(1,1,{0,0},8)  -- serial 50% pwm as fast as possible, lasts 8 cycles , gpio.serout(1,0,{20,10,10,20,10,10,10,100}) -- sim uart one byte 0x5A at about 100kbps , gpio.serout(1,1,{8,18},8) -- serial 30% pwm 38k, lasts 8 cycles"
    }
    
    trig = {
        description = "Establish or clear a callback function to run on interrupt for a pin. , This function is not available if GPIO_INTERRUPT_ENABLE was undefined at compile time."
        syntax = "gpio.trig(pin, [type [, callback_function]])"
        parameters = "- pin **1-12**, pin to trigger on, IO index. Note that pin 0 does not support interrupts. , - type "up", "down", "both", "low", "high", which represent *rising edge*, *falling edge*, *both  , edges*, *low level*, and *high level* trigger modes respectivey. If the type is "none" or omitted  , then the callback function is removed and the interrupt is disabled. , - callback_function(level) callback function when trigger occurs. The level of the specified pin  , at the interrupt passed as the parameter to the callback. The previous callback function will be  , used if the function is omitted."
        returns = "nil"
        example = "lua , do ,   -- use pin 1 as the input pulse width counter ,   local pin, pulse1, du, now, trig = 1, 0, 0, tmr.now, gpio.trig ,   gpio.mode(pin,gpio.INT) ,   local function pin1cb(level) ,     local pulse2 = now() ,     print( level, pulse2 - pulse1 ) ,     pulse1 = pulse2 ,     trig(pin, level == gpio.HIGH  and "down" or "up") ,   end ,   trig(pin, "down", pin1cb) , end , "
        seealso = "[gpio.mode()](#gpiomode)"
    }
    
    write = {
        description = "Set digital GPIO pin value."
        syntax = "gpio.write(pin, level)"
        parameters = "- pin pin to write, IO index , - level gpio.HIGH or gpio.LOW"
        returns = "nil"
        example = "lua , -- set pin index 1 to GPIO mode, and set the pin to high. , pin=1 , gpio.mode(pin, gpio.OUTPUT) , gpio.write(pin, gpio.HIGH) , "
        seealso = "- [gpio.mode()](#gpiomode) , - [gpio.read()](#gpioread)"
    }

}
http = {
    
    delete = {
        description = "Executes a HTTP DELETE request. Note that concurrent requests are not supported."
        syntax = "http.delete(url, headers, body, callback)"
        parameters = "- url The URL to fetch, including the http:// or https:// prefix , - headers Optional additional headers to append, *including \r\n*; may be nil , - body The body to post; must already be encoded in the appropriate format, but may be empty , - callback The callback function to be invoked when the response has been received; it is invoked with the arguments status_code and body"
        returns = "nil"
        example = "lua , http.delete('http://httpbin.org/delete', ,   "", ,   "", ,   function(code, data) ,     if (code < 0) then ,       print("HTTP request failed") ,     else ,       print(code, data) ,     end ,   end)"
    }
    
    get = {
        description = "Executes a HTTP GET request. Note that concurrent requests are not supported."
        syntax = "http.get(url, headers, callback)"
        parameters = "- url The URL to fetch, including the http:// or https:// prefix , - headers Optional additional headers to append, *including \r\n*; may be nil , - callback The callback function to be invoked when the response has been received; it is invoked with the arguments status_code and body"
        returns = "nil"
        example = "lua , http.get("http://httpbin.org/ip", nil, function(code, data) ,     if (code < 0) then ,       print("HTTP request failed") ,     else ,       print(code, data) ,     end ,   end)"
    }
    
    post = {
        description = "Executes a HTTP POST request. Note that concurrent requests are not supported."
        syntax = "http.post(url, headers, body, callback)"
        parameters = "- url The URL to fetch, including the http:// or https:// prefix , - headers Optional additional headers to append, *including \r\n*; may be nil , - body The body to post; must already be encoded in the appropriate format, but may be empty , - callback The callback function to be invoked when the response has been received; it is invoked with the arguments status_code and body"
        returns = "nil"
        example = "lua , http.post('http://httpbin.org/post', ,   'Content-Type: application/json\r\n', ,   '{"hello":"world"}', ,   function(code, data) ,     if (code < 0) then ,       print("HTTP request failed") ,     else ,       print(code, data) ,     end ,   end)"
    }
    
    put = {
        description = "Executes a HTTP PUT request. Note that concurrent requests are not supported."
        syntax = "http.put(url, headers, body, callback)"
        parameters = "- url The URL to fetch, including the http:// or https:// prefix , - headers Optional additional headers to append, *including \r\n*; may be nil , - body The body to post; must already be encoded in the appropriate format, but may be empty , - callback The callback function to be invoked when the response has been received; it is invoked with the arguments status_code and body"
        returns = "nil"
        example = "lua , http.put('http://httpbin.org/put', ,   'Content-Type: text/plain\r\n', ,   'Hello!\nStay a while, and listen...\n', ,   function(code, data) ,     if (code < 0) then ,       print("HTTP request failed") ,     else ,       print(code, data) ,     end ,   end)"
    }
    
    request = {
        description = "Execute a custom HTTP request for any HTTP method. Note that concurrent requests are not supported."
        syntax = "http.request(url, method, headers, body, callback)"
        parameters = "- url The URL to fetch, including the http:// or https:// prefix , - method The HTTP method to use, e.g. "GET", "HEAD", "OPTIONS" etc , - headers Optional additional headers to append, *including \r\n*; may be nil , - body The body to post; must already be encoded in the appropriate format, but may be empty , - callback The callback function to be invoked when the response has been received; it is invoked with the arguments status_code and body"
        returns = "nil"
        example = "lua , http.request("http://httpbin.org", "HEAD", "", "",  ,   function(code, data) ,     if (code < 0) then ,       print("HTTP request failed") ,     else ,       print(code, data) ,     end ,   end) , "
    }

}
hx711 = {
    
    init = {
        description = "Initialize io pins for hx711 clock and data."
        syntax = "hx711.init(clk, data)"
        parameters = "- clk pin the hx711 clock signal is connected to , - data pin the hx711 data signal is connected to"
        returns = "nil"
        example = "lua , -- Initialize the hx711 with clk on pin 5 and data on pin 6 , hx711.init(5,6)"
    }
    
    read = {
        description = "Read digital loadcell ADC value."
        syntax = "hx711.read(mode)"
        parameters = "mode ADC mode.  This parameter is currently ignored and reserved to ensure backward compatability if support for additional modes is added. Currently only channel A @ 128 gain is supported. , |mode | channel | gain | , |-----|---------|------| , | 0   | A       | 128  |"
        returns = "a number (24 bit signed ADC value extended to the machine int size)"
        example = "lua , -- Read ch A with 128 gain. , raw_data = hx711.read(0) , "
    }

}
i2c = {
    
    address = {
        description = "Setup I²C address and read/write mode for the next transfer."
        syntax = "i2c.address(id, device_addr, direction)"
        parameters = "- id always 0 , - device_addr device address , - direction i2c.TRANSMITTER for writing mode , i2c. RECEIVER for reading mode"
        returns = "true if ack received, false if no ack received."
        seealso = "[i2c.read()](#i2cread)"
    }
    
    read = {
        description = "Read data for variable number of bytes."
        syntax = "i2c.read(id, len)"
        parameters = "- id always 0 , - len number of data bytes"
        returns = "string of received data"
        example = "lua , id  = 0 , sda = 1 , scl = 2 , -- initialize i2c, set pin1 as sda, set pin2 as scl , i2c.setup(id, sda, scl, i2c.SLOW) , -- user defined function: read from reg_addr content of dev_addr , function read_reg(dev_addr, reg_addr) ,     i2c.start(id) ,     i2c.address(id, dev_addr, i2c.TRANSMITTER) ,     i2c.write(id, reg_addr) ,     i2c.stop(id) ,     i2c.start(id) ,     i2c.address(id, dev_addr, i2c.RECEIVER) ,     c = i2c.read(id, 1) ,     i2c.stop(id) ,     return c , end , -- get content of register 0xAA of device 0x77 , reg = read_reg(0x77, 0xAA) , print(string.byte(reg)) , "
        seealso = "[i2c.write()](#i2cwrite)"
    }
    
    setup = {
        description = "Initialize the I²C module."
        syntax = "i2c.setup(id, pinSDA, pinSCL, speed)"
        parameters = "- id always 0 , - pinSDA 1~12, IO index , - pinSCL 1~12, IO index , - speed only i2c.SLOW supported"
        returns = "speed the selected speed"
        seealso = "[i2c.read()](#i2cread)"
    }
    
    start = {
        description = "Send an I²C start condition."
        syntax = "i2c.start(id)"
        parameters = "id always 0"
        returns = "nil"
        seealso = "[i2c.read()](#i2cread)"
    }
    
    stop = {
        description = "Send an I²C stop condition."
        syntax = "i2c.stop(id)"
        parameters = "id always 0"
        returns = "nil"
        seealso = "[i2c.read()](#i2cread)"
    }
    
    write = {
        description = "Write data to I²C bus. Data items can be multiple numbers, strings or lua tables."
        syntax = "i2c.write(id, data1[, data2[, ..., datan]])"
        parameters = "- id always 0 , - data data can be numbers, string or lua table."
        returns = "number number of bytes written"
        example = "lua , i2c.write(0, "hello", "world") , "
        seealso = "[i2c.read()](#i2cread)"
    }

}
mdns = {
    
    register = {
        description = "Register a hostname and start the mDNS service. If the service is already running, then it will be restarted with the new parameters."
        syntax = "mdns.register(hostname [, attributes])"
        parameters = "- hostname The hostname for this device. Alphanumeric characters are best. , - attributes A optional table of options. The keys must all be strings. , The attributes contains two sorts of attributes -- those with specific names, and those that are service specific. [RFC 6763](https://tools.ietf.org/html/rfc6763#page-13)  , defines how extra, service specific, attributes are encoded into the DNS. One example is that if the device supports printing, then the queue name can  , be specified as an additional attribute. This module supports up to 10 such attributes. , The specific names are: , - port The port number for the service. Default value is 80. , - service The name of the service. Default value is 'http'. , - dscription A short phrase (under 63 characters) describing the service. Default is the hostname."
        returns = "nil , #####Errors , Various errors can be generated during argument validation. The NodeMCU must have an IP address at the time of the call, otherwise an error is thrown."
        example = "    mdns.register("fishtank", {hardware='NodeMCU'}) , Using dns-sd on OS X, you can see fishtank.local as providing the _http._tcp service. You can also browse directly to fishtank.local. In Safari you can get all the mDNS web pages as part of your bookmarks menu. ,     mdns.register("fishtank", { description="Top Fishtank", service="http", port=80, location='Living Room' })"
    }
    
    close = {
        description = "Shut down the mDNS service. This is not normally needed."
        syntax = "mdns.close()"
        parameters = "none"
        returns = "nil"
    }

}
mqtt = {
    
    Client = {
        description = "Creates a MQTT client."
        syntax = "mqtt.Client(clientid, keepalive, username, password[, cleansession])"
        parameters = "- clientid client ID , - keepalive keepalive seconds , - username user name , - password user password , - cleansession 0/1 for false/true"
        returns = "MQTT client"
        example = "lua , -- init mqtt client with keepalive timer 120sec , m = mqtt.Client("clientid", 120, "user", "password") , -- setup Last Will and Testament (optional) , -- Broker will publish a message with qos = 0, retain = 0, data = "offline"  , -- to topic "/lwt" if client don't send keepalive packet , m:lwt("/lwt", "offline", 0, 0) , m:on("connect", function(client) print ("connected") end) , m:on("offline", function(client) print ("offline") end) , -- on publish message receive event , m:on("message", function(client, topic, data)  ,   print(topic .. ":" )  ,   if data ~= nil then ,     print(data) ,   end , end) , -- for TLS: m:connect("192.168.11.118", secure-port, 1) , m:connect("192.168.11.118", 1883, 0, function(client) print("connected") end,  ,                                      function(client, reason) print("failed reason: "..reason) end) , -- Calling subscribe/publish only makes sense once the connection , -- was successfully established. In a real-world application you want , -- move those into the 'connect' callback or make otherwise sure the  , -- connection was established. , -- subscribe topic with qos = 0 , m:subscribe("/topic",0, function(client) print("subscribe success") end) , -- publish a message with data = hello, QoS = 0, retain = 0 , m:publish("/topic","hello",0,0, function(client) print("sent") end) , m:close(); , -- you can call m:connect again ,  , ####MQTT Client"
    }
    
    client:close = {
        description = "Closes connection to the broker."
        syntax = "mqtt:close()"
        parameters = "none"
        returns = "true on success, false otherwise"
    }
    
    client:connect = {
        description = "Connects to the broker specified by the given host, port, and secure options."
        syntax = "mqtt:connect(host[, port[, secure[, autoreconnect]]][, function(client)[, function(client, reason)]])"
        parameters = "- host host, domain or IP (string) , - port broker port (number), default 1883 , - secure 0/1 for false/true, default 0. Take note of constraints documented in the [net module](net.md). , - autoreconnect 0/1 for false/true, default 0 , - function(client) callback function for when the connection was established , - function(client, reason) callback function for when the connection could not be established"
        returns = "true on success, false otherwise , #####Connection failure callback reason codes: , | Constant | Value | Description | , |----------|-------|-------------| , |mqtt.CONN_FAIL_SERVER_NOT_FOUND|-5|There is no broker listening at the specified IP Address and Port| , |mqtt.CONN_FAIL_NOT_A_CONNACK_MSG|-4|The response from the broker was not a CONNACK as required by the protocol| , |mqtt.CONN_FAIL_DNS|-3|DNS Lookup failed| , |mqtt.CONN_FAIL_TIMEOUT_RECEIVING|-2|Timeout waiting for a CONNACK from the broker| , |mqtt.CONN_FAIL_TIMEOUT_SENDING|-1|Timeout trying to send the Connect message| , |mqtt.CONNACK_ACCEPTED|0|No errors. _Note: This will not trigger a failure callback._| , |mqtt.CONNACK_REFUSED_PROTOCOL_VER|1|The broker is not a 3.1.1 MQTT broker.| , |mqtt.CONNACK_REFUSED_ID_REJECTED|2|The specified ClientID was rejected by the broker. (See mqtt.Client())| , |mqtt.CONNACK_REFUSED_SERVER_UNAVAILABLE|3|The server is unavailable.| , |mqtt.CONNACK_REFUSED_BAD_USER_OR_PASS|4|The broker refused the specified username or password.| , |mqtt.CONNACK_REFUSED_NOT_AUTHORIZED|5|The username is not authorized.|"
    }
    
    client:lwt = {
        description = "Setup [Last Will and Testament](http://www.hivemq.com/blog/mqtt-essentials-part-9-last-will-and-testament) (optional). A broker will publish a message with qos = 0, retain = 0, data = "offline" to topic "/lwt" if client does not send keepalive packet."
        syntax = "mqtt:lwt(topic, message[, qos[, retain]])"
        parameters = "- topic the topic to publish to (string) , - message the message to publish, (buffer or string) , - qos QoS level, default 0 , - retain retain flag, default 0"
        returns = "nil"
    }
    
    client:on = {
        description = "Registers a callback function for an event."
        syntax = "mqtt:on(event, function(client[, topic[, message]]))"
        parameters = "- event can be "connect", "message" or "offline" , - function(client[, topic[, message]]) callback function. The first parameter is the client. If event is "message", the 2nd and 3rd param are received topic and message (strings)."
        returns = "nil"
    }
    
    client:publish = {
        description = "Publishes a message."
        syntax = "mqtt:publish(topic, payload, qos, retain[, function(client)])"
        parameters = "- topic the topic to publish to ([topic string](http://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices)) , - message the message to publish, (buffer or string) , - qos QoS level , - retain retain flag , - function(client) optional callback fired when PUBACK received.  NOTE: When calling publish() more than once, the last callback function defined will be called for ALL publish commands. ,   "
        returns = "true on success, false otherwise"
    }
    
    client:subscribe = {
        description = "Subscribes to one or several topics."
        syntax = "mqtt:subscribe(topic, qos[, function(client)]) , mqtt:subscribe(table[, function(client)])"
        parameters = "- topic a [topic string](http://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices) , - qos QoS subscription level, default 0 , - table array of 'topic, qos' pairs to subscribe to , - function(client) optional callback fired when subscription(s) succeeded.  NOTE: When calling subscribe() more than once, the last callback function defined will be called for ALL subscribe commands."
        returns = "true on success, false otherwise"
        example = "lua , -- subscribe topic with qos = 0 , m:subscribe("/topic",0, function(conn) print("subscribe success") end) , -- or subscribe multiple topic (topic/0, qos = 0; topic/1, qos = 1; topic2 , qos = 2) , m:subscribe({["topic/0"]=0,["topic/1"]=1,topic2=2}, function(conn) print("subscribe success") end)"
    }
    
    client:unsubscribe = {
        description = "Unsubscribes from one or several topics."
        syntax = "mqtt:unsubscribe(topic[, function(client)]) , mqtt:unsubscribe(table[, function(client)])"
        parameters = "- topic a [topic string](http://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices) , - table array of 'topic, anything' pairs to unsubscribe from , - function(client) optional callback fired when unsubscription(s) succeeded.  NOTE: When calling unsubscribe() more than once, the last callback function defined will be called for ALL unsubscribe commands."
        returns = "true on success, false otherwise"
        example = "lua , -- unsubscribe topic , m:unsubscribe("/topic", function(conn) print("unsubscribe success") end) , -- or unsubscribe multiple topic (topic/0; topic/1; topic2) , m:unsubscribe({["topic/0"]=0,["topic/1"]=0,topic2="anything"}, function(conn) print("unsubscribe success") end) , "
    }

}
net = {
    
    createConnection = {
        description = "Creates a client."
        syntax = "net.createConnection(type, secure)"
        parameters = "- type net.TCP or net.UDP , - secure 1 for encrypted, 0 for plain"
        returns = "net.socket sub module"
        example = "lua , net.createConnection(net.UDP, 0) , "
        seealso = "[net.createServer()](#netcreateserver)"
    }
    
    createServer = {
        description = "Creates a server."
        syntax = "net.createServer(type, timeout)"
        parameters = "- type net.TCP or net.UDP , - timeout for a TCP server timeout is 1~28'800 seconds (for an inactive client to be disconnected)"
        returns = "net.server sub module"
        example = "lua , net.createServer(net.TCP, 30) -- 30s timeout , "
        seealso = "[net.createConnection()](#netcreateconnection)"
    }
    
    multicastJoin = {
        description = "Join multicast group."
        syntax = "net.multicastJoin(if_ip, multicast_ip)"
        parameters = "- if_ip string containing the interface ip to join the multicast group. "any" or "" affects all interfaces. , - multicast_ip of the group to join"
        returns = "nil"
    }
    
    multicastLeave = {
        description = "Leave multicast group."
        syntax = "net.multicastLeave(if_ip, multicast_ip)"
        parameters = "- if_ip string containing the interface ip to leave the multicast group. "any" or "" affects all interfaces. , - multicast_ip of the group to leave"
        returns = "nil , ####net.server Module"
    }
    
    server:close = {
        description = "Closes the server."
        syntax = "net.server.close()"
        parameters = "none"
        returns = "nil"
        example = "lua , -- creates a server , sv = net.createServer(net.TCP, 30) , -- closes the server , sv:close() , "
        seealso = "[net.createServer()](#netcreateserver)"
    }
    
    server:listen = {
        description = "Listen on port from IP address."
        syntax = "net.server.listen(port,[ip],function(net.socket))"
        parameters = "- port port number , - ip IP address string, can be omitted , - function(net.socket) callback function, pass to caller function as param if a connection is created successfully"
        returns = "nil"
        example = "lua ,  -- 30s time out for a inactive client , sv = net.createServer(net.TCP, 30) , -- server listens on 80, if data received, print data to console and send "hello world" back to caller , sv:listen(80, function(c) ,   c:on("receive", function(c, pl)  ,     print(pl) ,   end) ,   c:send("hello world") , end) , "
        seealso = "[net.createServer()](#netcreateserver)"
    }
    
    server:on = {
        description = "UDP server only: Register callback functions for specific events."
        seealso = "[net.socket:on()](#netsocketon)"
    }
    
    server:send = {
        description = "UDP server only: Sends data to remote peer."
        seealso = "[net.socket:send()](#netsocketsend) , ####net.socket Module"
    }
    
    socket:close = {
        description = "Closes socket."
        syntax = "close()"
        parameters = "none"
        returns = "nil"
        seealso = "[net.createServer()](#netcreateserver)"
    }
    
    socket:connect = {
        description = "Connect to a remote server."
        syntax = "connect(port, ip|domain)"
        parameters = "- port port number , - ip IP address or domain name string"
        returns = "nil"
        seealso = "[net.socket:on()](#netsocketon)"
    }
    
    socket:dns = {
        description = "Provides DNS resolution for a hostname."
        syntax = "dns(domain, function(net.socket, ip))"
        parameters = "- domain domain name , - function(net.socket, ip) callback function. The first parameter is the socket, the second parameter is the IP address as a string."
        returns = "nil"
        example = "lua , sk = net.createConnection(net.TCP, 0) , sk:dns("www.nodemcu.com", function(conn, ip) print(ip) end) , sk = nil , "
        seealso = "[net.createServer()](#netcreateserver)"
    }
    
    socket:getpeer = {
        description = "Retrieve port and ip of peer."
        syntax = "getpeer()"
        parameters = "none"
        returns = "- ip of peer , - port of peer"
    }
    
    socket:hold = {
        description = "Throttle data reception by placing a request to block the TCP receive function. This request is not effective immediately, Espressif recommends to call it while reserving 5*1460 bytes of memory."
        syntax = "hold()"
        parameters = "none"
        returns = "nil"
        seealso = "[net.socket:unhold()](#netsocketunhold)"
    }
    
    socket:on = {
        description = "Register callback functions for specific events."
        syntax = "on(event, function())"
        parameters = "- event string, which can be "connection", "reconnection", "disconnection", "receive" or "sent" , - function(net.socket[, string]) callback function. The first parameter is the socket. If event is "receive", the second parameter is the received data as string."
        returns = "nil"
        example = "lua , srv = net.createConnection(net.TCP, 0) , srv:on("receive", function(sck, c) print(c) end) , srv:connect(80,"192.168.0.66") , srv:on("connection", function(sck, c) ,   -- Wait for connection before sending. ,   sck:send("GET / HTTP/1.1\r\nHost: 192.168.0.66\r\nConnection: keep-alive\r\nAccept: */*\r\n\r\n") , end) , "
        seealso = "- [net.createServer()](#netcreateserver) , - [net.socket:hold()](#netsockethold)"
    }
    
    socket:send = {
        description = "Sends data to remote peer."
        syntax = "send(string[, function(sent)]) , sck:send(data, fnA) is functionally equivalent to sck:send(data) sck:on("sent", fnA)."
        parameters = "- string data in string which will be sent to server , - function(sent) callback function for sending string"
        returns = "nil , #####Note , Multiple consecutive send() calls aren't guaranteed to work (and often don't) as network requests are treated as separate tasks by the SDK. Instead, subscribe to the "sent" event on the socket and send additional data (or close) in that callback. See [#730](https://github.com/nodemcu/nodemcu-firmware/issues/730#issuecomment-154241161) for details."
        example = "lua , srv = net.createServer(net.TCP) , srv:listen(80, function(conn) ,   conn:on("receive", function(sck, req) ,     local response = {} ,     -- if you're sending back HTML over HTTP you'll want something like this instead ,     -- local response = {"HTTP/1.0 200 OK\r\nServer: NodeMCU on ESP8266\r\nContent-Type: text/html\r\n\r\n"} ,     response[#response + 1] = "lots of data" ,     response[#response + 1] = "even more data" ,     response[#response + 1] = "e.g. content read from a file" ,      , 	 -- sends and removes the first element from the 'response' table ,     local function send(sk) ,       if #response > 0 ,         then sk:send(table.remove(response, 1)) ,       else ,         sk:close() ,         response = nil ,       end ,     end ,     -- triggers the send() function again once the first chunk of data was sent ,     sck:on("sent", send) ,      ,     send(sck) ,   end) , end) ,  , If you do not or can not keep all the data you send back in memory at one time (remember that response is an aggregation) you may use explicit callbacks instead of building up a table like so: , lua , sck:send(header, function()  ,   local data1 = "some large chunk of dynamically loaded data" ,   sck:send(data1, function() ,     local data2 = "even more dynamically loaded data" ,     sck:send(data2, function(sk)  ,       sk:close() ,     end) ,   end) , end) , "
        seealso = "[net.socket:on()](#netsocketon)"
    }
    
    socket:unhold = {
        description = "Unblock TCP receiving data by revocation of a preceding hold()."
        syntax = "unhold()"
        parameters = "none"
        returns = "nil"
        seealso = "[net.socket:hold()](#netsockethold) , ####net.dns Module"
    }
    
    dns.getdnsserver = {
        description = "Gets the IP address of the DNS server used to resolve hostnames."
        syntax = "net.dns.getdnsserver(dns_index)"
        parameters = "dns_index which DNS server to get (range 0~1)"
        returns = "IP address (string) of DNS server"
        example = "lua , print(net.dns.getdnsserver(0)) -- 208.67.222.222 , print(net.dns.getdnsserver(1)) -- nil , net.dns.setdnsserver("8.8.8.8", 0) , net.dns.setdnsserver("192.168.1.252", 1) , print(net.dns.getdnsserver(0)) -- 8.8.8.8 , print(net.dns.getdnsserver(1)) -- 192.168.1.252 , "
        seealso = "[net.dns:setdnsserver()](#netdnssetdnsserver)"
    }
    
    dns.resolve = {
        description = "Resolve a hostname to an IP address. Doesn't require a socket like [net.socket.dns()](#netsocketdns)."
        syntax = "net.dns.resolve(host, function(ip))"
        parameters = "- host hostname to resolve , - function(sk, ip) callback called when the name was resolved. Don't use sk, it's a socket used internally to resolve the hostname."
        returns = "nil"
        example = "lua , net.dns.resolve("www.google.com", function(sk, ip) ,     if (ip == nil) then print("DNS fail!") else print(ip) end , end) , "
        seealso = "[net.socket:dns()](#netsocketdns)"
    }
    
    dns.setdnsserver = {
        description = "Sets the IP of the DNS server used to resolve hostnames. Default: resolver1.opendns.com (208.67.222.222). You can specify up to 2 DNS servers."
        syntax = "net.dns.setdnsserver(dns_ip_addr, dns_index)"
        parameters = "- dns_ip_addr IP address of a DNS server , - dns_index which DNS server to set (range 0~1). Hence, it supports max. 2 servers. "
        returns = "nil"
        seealso = "[net.dns:getdnsserver()](#netdnsgetdnsserver) , ####net.cert Module , This controls certificate verification when SSL is in use. "
    }
    
    cert.verify = {
        description = "Controls the vertificate verification process when the Nodemcu makes a secure connection."
        syntax = "net.cert.verify(enable) , net.cert.verify(pemdata)"
        parameters = "- enable A boolean which indicates whether verification should be enabled or not. The default at boot is false. , - pemdata A string containing the CA certificate to use for verification."
        returns = "true if it worked.  , Can throw a number of errors if invalid data is supplied."
        example = "Make a secure https connection and verify that the certificate chain is valid. ,  , net.cert.verify(true) , http.get("https://example.com/info", nil, function (code, resp) print(code, resp) end) ,  , Load a certificate into the flash chip and make a request. This is the [startssl](https://startssl.com) root certificate. They provide free , certificates. ,  , net.cert.verify([[ , -----BEGIN CERTIFICATE----- , MIIHyTCCBbGgAwIBAgIBATANBgkqhkiG9w0BAQUFADB9MQswCQYDVQQGEwJJTDEW , MBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwg , Q2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNh , dGlvbiBBdXRob3JpdHkwHhcNMDYwOTE3MTk0NjM2WhcNMzYwOTE3MTk0NjM2WjB9 , MQswCQYDVQQGEwJJTDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMi , U2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUgU2lnbmluZzEpMCcGA1UEAxMgU3Rh , cnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA , A4ICDwAwggIKAoICAQDBiNsJvGxGfHiflXu1M5DycmLWwTYgIiRezul38kMKogZk , pMyONvg45iPwbm2xPN1yo4UcodM9tDMr0y+v/uqwQVlntsQGfQqedIXWeUyAN3rf , OQVSWff0G0ZDpNKFhdLDcfN1YjS6LIp/Ho/u7TTQEceWzVI9ujPW3U3eCztKS5/C , Ji/6tRYccjV3yjxd5srhJosaNnZcAdt0FCX+7bWgiA/deMotHweXMAEtcnn6RtYT , Kqi5pquDSR3l8u/d5AGOGAqPY1MWhWKpDhk6zLVmpsJrdAfkK+F2PrRt2PZE4XNi , HzvEvqBTViVsUQn3qqvKv3b9bZvzndu/PWa8DFaqr5hIlTpL36dYUNk4dalb6kMM , Av+Z6+hsTXBbKWWc3apdzK8BMewM69KN6Oqce+Zu9ydmDBpI125C4z/eIT574Q1w , +2OqqGwaVLRcJXrJosmLFqa7LH4XXgVNWG4SHQHuEhANxjJ/GP/89PrNbpHoNkm+ , Gkhpi8KWTRoSsmkXwQqQ1vp5Iki/untp+HDH+no32NgN0nZPV/+Qt+OR0t3vwmC3 , Zzrd/qqc8NSLf3Iizsafl7b4r4qgEKjZ+xjGtrVcUjyJthkqcwEKDwOzEmDyei+B , 26Nu/yYwl/WL3YlXtq09s68rxbd2AvCl1iuahhQqcvbjM4xdCUsT37uMdBNSSwID , AQABo4ICUjCCAk4wDAYDVR0TBAUwAwEB/zALBgNVHQ8EBAMCAa4wHQYDVR0OBBYE , FE4L7xqkQFulF2mHMMo0aEPQQa7yMGQGA1UdHwRdMFswLKAqoCiGJmh0dHA6Ly9j , ZXJ0LnN0YXJ0Y29tLm9yZy9zZnNjYS1jcmwuY3JsMCugKaAnhiVodHRwOi8vY3Js , LnN0YXJ0Y29tLm9yZy9zZnNjYS1jcmwuY3JsMIIBXQYDVR0gBIIBVDCCAVAwggFM , BgsrBgEEAYG1NwEBATCCATswLwYIKwYBBQUHAgEWI2h0dHA6Ly9jZXJ0LnN0YXJ0 , Y29tLm9yZy9wb2xpY3kucGRmMDUGCCsGAQUFBwIBFilodHRwOi8vY2VydC5zdGFy , dGNvbS5vcmcvaW50ZXJtZWRpYXRlLnBkZjCB0AYIKwYBBQUHAgIwgcMwJxYgU3Rh , cnQgQ29tbWVyY2lhbCAoU3RhcnRDb20pIEx0ZC4wAwIBARqBl0xpbWl0ZWQgTGlh , YmlsaXR5LCByZWFkIHRoZSBzZWN0aW9uICpMZWdhbCBMaW1pdGF0aW9ucyogb2Yg , dGhlIFN0YXJ0Q29tIENlcnRpZmljYXRpb24gQXV0aG9yaXR5IFBvbGljeSBhdmFp , bGFibGUgYXQgaHR0cDovL2NlcnQuc3RhcnRjb20ub3JnL3BvbGljeS5wZGYwEQYJ , YIZIAYb4QgEBBAQDAgAHMDgGCWCGSAGG+EIBDQQrFilTdGFydENvbSBGcmVlIFNT , TCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTANBgkqhkiG9w0BAQUFAAOCAgEAFmyZ , 9GYMNPXQhV59CuzaEE44HF7fpiUFS5Eyweg78T3dRAlbB0mKKctmArexmvclmAk8 , jhvh3TaHK0u7aNM5Zj2gJsfyOZEdUauCe37Vzlrk4gNXcGmXCPleWKYK34wGmkUW , FjgKXlf2Ysd6AgXmvB618p70qSmD+LIU424oh0TDkBreOKk8rENNZEXO3SipXPJz , ewT4F+irsfMuXGRuczE6Eri8sxHkfY+BUZo7jYn0TZNmezwD7dOaHZrzZVD1oNB1 , ny+v8OqCQ5j4aZyJecRDjkZy42Q2Eq/3JR44iZB3fsNrarnDy0RLrHiQi+fHLB5L , EUTINFInzQpdn4XBidUaePKVEFMy3YCEZnXZtWgo+2EuvoSoOMCZEoalHmdkrQYu , L6lwhceWD3yJZfWOQ1QOq92lgDmUYMA0yZZwLKMS9R9Ie70cfmu3nZD0Ijuu+Pwq , yvqCUqDvr0tVk+vBtfAii6w0TiYiBKGHLHVKt+V9E9e4DGTANtLJL4YSjCMJwRuC , O3NJo2pXh5Tl1njFmUNj403gdy3hZZlyaQQaRwnmDwFWJPsfvw55qVguucQJAX6V , um0ABj6y6koQOdjQK/W/7HW/lwLFCRsI3FU34oH7N4RDYiDK51ZLZer+bMEkkySh , NOsF/5oirpt9P/FlUQqmMGqz9IgcgA38corog14= , -----END CERTIFICATE----- , ]]) , http.get("https://pskreporter.info/gen404", nil, function (code, resp) print(code, resp) end) ,  , #####Notes , The certificate needed for verification is stored in the flash chip. The net.cert.verify call with true , enables verification against the value stored in the flash.  , The certificate can be loaded into the flash chip in two ways -- one at firmware build time, and the other at initial boot , of the firmware. In order to load the certificate at build time, just place a file containing the CA certificate (in PEM format)  , at server-ca.crt in the root of the nodemcu-firmware build tree. The build scripts will incorporate this into the resulting , firmware image. , The alternative approach is easier for development, and that is to supply the PEM data as a string value to net.cert.verify. This , will store the certificate into the flash chip and turn on verification for that certificate. Subsequent boots of the nodemcu can then , use net.cert.verify(true) and use the stored certificate."
    }

}
node = {
    
    bootreason = {
        description = "Returns the boot reason and extended reset info. , The first value returned is the raw code, not the new "reset info" code which was introduced in recent SDKs. Values are: ,   - 1, power-on ,   - 2, reset (software?) ,   - 3, hardware reset via reset pin ,   - 4, WDT reset (watchdog timeout) , The second value returned is the extended reset cause. Values are: ,   - 0, power-on ,   - 1, hardware watchdog reset ,   - 2, exception reset ,   - 3, software watchdog reset ,   - 4, software restart ,   - 5, wake from deep sleep ,   - 6, external reset , In general, the extended reset cause supercedes the raw code. The raw code is kept for backwards compatibility only. For new applications it is highly recommended to use the extended reset cause instead. , In case of extended reset cause 3 (exception reset), additional values are returned containing the crash information. These are, in order, EXCCAUSE, EPC1, EPC2, EPC3, EXCVADDR, and DEPC."
        syntax = "node.bootreason()"
        parameters = "none"
        returns = "rawcode, reason [, exccause, epc1, epc2, epc3, excvaddr, depc ]"
        example = "lua , _, reset_reason = node.bootreason() , if reset_reason == 0 then print("Power UP!") end"
    }
    
    chipid = {
        description = "Returns the ESP chip ID."
        syntax = "node.chipid()"
        parameters = "none"
        returns = "chip ID (number)"
    }
    
    compile = {
        description = "Compiles a Lua text file into Lua bytecode, and saves it as .lc file."
        syntax = "node.compile("file.lua")"
        parameters = "filename name of Lua text file"
        returns = "nil"
        example = "lua , file.open("hello.lua","w+") , file.writeline([[print("hello nodemcu")]]) , file.writeline([[print(node.heap())]]) , file.close() , node.compile("hello.lua") , dofile("hello.lua") , dofile("hello.lc")"
    }
    
    dsleep = {
        description = "Enters deep sleep mode, wakes up when timed out. , The maximum sleep time is 4294967295us, ~71 minutes. This is an SDK limitation. , Firmware from before 05 Jan 2016 have a maximum sleeptime of ~35 minutes. , !!! note "Note:" ,     This function can only be used in the condition that esp8266 PIN32(RST) and PIN8(XPD_DCDC aka GPIO16) are connected together. Using sleep(0) will set no wake up timer, connect a GPIO to pin RST, the chip will wake up by a falling-edge on pin RST."
        syntax = "node.dsleep(us, option)"
        parameters = " - us number (integer) or nil, sleep time in micro second. If us == 0, it will sleep forever. If us == nil, will not set sleep time. ,  - option number (integer) or nil. If nil, it will use last alive setting as default option. , 	- 0, init data byte 108 is valuable , 	- \> 0, init data byte 108 is valueless , 	- 0, RF_CAL or not after deep-sleep wake up, depends on init data byte 108 , 	- 1, RF_CAL after deep-sleep wake up, there will belarge current , 	- 2, no RF_CAL after deep-sleep wake up, there will only be small current , 	- 4, disable RF after deep-sleep wake up, just like modem sleep, there will be the smallest current"
        returns = "nil"
        example = "lua , --do nothing , node.dsleep() , --sleep μs , node.dsleep(1000000) , --set sleep option, then sleep μs , node.dsleep(1000000, 4) , --set sleep option only , node.dsleep(nil,4)"
    }
    
    flashid = {
        description = "Returns the flash chip ID."
        syntax = "node.flashid()"
        parameters = "none"
        returns = "flash ID (number)"
    }
    
    heap = {
        description = "Returns the current available heap size in bytes. Note that due to fragmentation, actual allocations of this size may not be possible."
        syntax = "node.heap()"
        parameters = "none"
        returns = "system heap size left in bytes (number)"
    }
    
    info = {
        description = "Returns NodeMCU version, chipid, flashid, flash size, flash mode, flash speed."
        syntax = "node.info()"
        parameters = "none"
        returns = " - majorVer (number) ,  - minorVer (number) ,  - devVer (number) ,  - chipid (number) ,  - flashid (number) ,  - flashsize (number) ,  - flashmode (number) ,  - flashspeed (number)"
        example = "lua , majorVer, minorVer, devVer, chipid, flashid, flashsize, flashmode, flashspeed = node.info() , print("NodeMCU "..majorVer.."."..minorVer.."."..devVer)"
    }
    
    input = {
        description = "Submits a string to the Lua interpreter. Similar to pcall(loadstring(str)), but without the single-line limitation. , !!! note "Note:" ,     This function only has an effect when invoked from a callback. Using it directly on the console **does not work**."
        syntax = "node.input(str)"
        parameters = "str Lua chunk"
        returns = "nil"
        example = "lua , sk:on("receive", function(conn, payload) node.input(payload) end) , "
        seealso = "[node.output()](#nodeoutput)"
    }
    
    key = {
        description = "Defines action to take on button press (on the old devkit 0.9), button connected to GPIO 16. , This function is only available if the firmware was compiled with DEVKIT_VERSION_0_9 defined."
        syntax = "node.key(type, function())"
        parameters = "  - type: type is either string "long" or "short". long: press the key for 3 seconds, short: press shortly(less than 3 seconds) ,   - function: user defined function which is called when key is pressed. If nil, remove the user defined function. Default function: long: change LED blinking rate,  short: reset chip"
        returns = "nil"
        example = "lua , node.key("long", function() print('hello world') end) , "
        seealso = "[node.led()](#nodeled-deprecated)"
    }
    
    led = {
        description = "Sets the on/off time for the LED (on the old devkit 0.9), with the LED connected to GPIO16, multiplexed with [node.key()](#nodekey-deprecated). , This function is only available if the firmware was compiled with DEVKIT_VERSION_0_9 defined."
        syntax = "node.led(low, high)"
        parameters = "  - low LED off time, LED keeps on when low=0. Unit: milliseconds, time resolution: 80~100ms ,   - high LED on time. Unit: milliseconds, time resolution: 80~100ms"
        returns = "nil"
        example = "lua , -- turn led on forever. , node.led(0) , "
        seealso = "[node.key()](#nodekey-deprecated)"
    }
    
    output = {
        description = "Redirects the Lua interpreter output to a callback function. Optionally also prints it to the serial console. , !!! note "Note:" ,     Do **not** attempt to print() or otherwise induce the Lua interpreter to produce output from within the callback function. Doing so results in infinite recursion, and leads to a watchdog-triggered restart."
        syntax = "node.output(function(str), serial_debug)"
        parameters = "  - output_fn(str) a function accept every output as str, and can send the output to a socket (or maybe a file). ,   - serial_debug 1 output also show in serial. 0: no serial output."
        returns = "nil"
        example = "lua , function tonet(str) ,   sk:send(str) , end , node.output(tonet, 1)  -- serial also get the lua output. ,  , lua , -- a simple telnet server , s=net.createServer(net.TCP) , s:listen(2323,function(c) ,    con_std = c ,    function s_output(str) ,       if(con_std~=nil) ,          then con_std:send(str) ,       end ,    end ,    node.output(s_output, 0)   -- re-direct output to function s_ouput. ,    c:on("receive",function(c,l) ,       node.input(l)           -- works like pcall(loadstring(l)) but support multiple separate line ,    end) ,    c:on("disconnection",function(c) ,       con_std = nil ,       node.output(nil)        -- un-regist the redirect output function, output goes to serial ,    end) , end) , "
        seealso = "[node.input()](#nodeinput)"
    }
    
    readvdd33 = {
        description = "Moved to [adc.readvdd33()](adc/#adcreadvdd33)."
    }
    
    restart = {
        description = "Restarts the chip."
        syntax = "node.restart()"
        parameters = "none"
        returns = "nil"
    }
    
    restore = {
        description = "Restores system configuration to defaults using the SDK function system_restore(), which doesn't document precisely what it erases/restores."
        syntax = "node.restore()"
        parameters = "none"
        returns = "nil"
        example = "lua , node.restore() , node.restart() -- ensure the restored settings take effect"
    }
    
    setcpufreq = {
        description = "Change the working CPU Frequency."
        syntax = "node.setcpufreq(speed)"
        parameters = "speed constant 'node.CPU80MHZ' or 'node.CPU160MHZ'"
        returns = "target CPU frequency (number)"
        example = "lua , node.setcpufreq(node.CPU80MHZ)"
    }
    
    stripdebug = {
        description = "Controls the amount of debug information kept during [node.compile()](#nodecompile), and allows removal of debug information from already compiled Lua code. , Only recommended for advanced users, the NodeMCU defaults are fine for almost all use cases."
        syntax = "node.stripdebug([level[, function]])"
        parameters = "- level , 	- 1, don't discard debug info , 	- 2, discard Local and Upvalue debug info , 	- 3, discard Local, Upvalue and line-number debug info , - function a compiled function to be stripped per setfenv except 0 is not permitted. , If no arguments are given then the current default setting is returned. If function is omitted, this is the default setting for future compiles. The function argument uses the same rules as for setfenv()."
        returns = "If invoked without arguments, returns the current level settings. Otherwise, nil is returned."
        example = "lua , node.stripdebug(3) , node.compile('bigstuff.lua') , "
        seealso = "[node.compile()](#nodecompile)"
    }
    
    osprint = {
        description = "Controls whether the debugging output from the Espressif SDK is printed. Note that this is only available if , the firmware is build with DEVELOPMENT_TOOLS defined."
        syntax = "node.osprint(enabled)"
        parameters = "- enabled This is either true to enable printing, or false to disable it. The default is false."
        returns = "Nothing"
        example = "lua , node.osprint(true) ,  , ####node.egc module"
    }
    
    egc.setmode = {
        description = "Sets the Emergency Garbage Collector mode. [The EGC whitepaper](http://www.eluaproject.net/doc/v0.9/en_elua_egc.html) , provides more detailed information on the EGC."
        syntax = "node.egc.setmode(mode, [param])"
        parameters = "- mode , 	- node.egc.NOT_ACTIVE EGC inactive, no collection cycle will be forced in low memory situations , 	- node.egc.ON_ALLOC_FAILURE Try to allocate a new block of memory, and run the garbage collector if the allocation fails. If the allocation fails even after running the garbage collector, the allocator will return with error.  , 	- node.egc.ON_MEM_LIMIT Run the garbage collector when the memory used by the Lua script goes beyond an upper limit. If the upper limit can't be satisfied even after running the garbage collector, the allocator will return with error. , 	- node.egc.ALWAYS Run the garbage collector before each memory allocation. If the allocation fails even after running the garbage collector, the allocator will return with error. This mode is very efficient with regards to memory savings, but it's also the slowest. , - level in the case of node.egc.ON_MEM_LIMIT, this specifies the memory limit. ,   "
        returns = "nil"
        example = "node.egc.setmode(node.egc.ALWAYS, 4096)  -- This is the default setting at startup. , node.egc.setmode(node.egc.ON_ALLOC_FAILURE) -- This is the fastest activeEGC mode. , ####node.task module"
    }
    
    task.post = {
        description = "Enable a Lua callback or task to post another task request. Note that as per the  , example multiple tasks can be posted in any task, but the highest priority is  , always delivered first. , If the task queue is full then a queue full error is raised.  "
        syntax = "node.task.post([task_priority], function)"
        parameters = "- task_priority (optional) , 	- node.task.LOW_PRIORITY = 0 , 	- node.task.MEDIUM_PRIORITY = 1 , 	- node.task.HIGH_PRIORITY = 2 , - function a callback function to be executed when the task is run.  , If the priority is omitted then  this defaults  to node.task.MEDIUM_PRIORITY"
        returns = "nil"
        example = "lua , for i = node.task.LOW_PRIORITY, node.task.HIGH_PRIORITY do  ,   node.task.post(i,function(p2) ,     print("priority is "..p2) ,   end)  , end       ,   , prints ,  , priority is 2 , priority is 1 , priority is 0 , "
    }

}
ow = {
    
    check_crc16 = {
        description = "Computes the 1-Wire CRC16 and compare it against the received CRC."
        syntax = "ow.check_crc16(buf, inverted_crc0, inverted_crc1[, crc])"
        parameters = "  - buf string value, data to be calculated check sum in string ,   - inverted_crc0 LSB of received CRC ,   - inverted_crc1 MSB of received CRC ,   - crc CRC starting value (optional)"
        returns = "true if the CRC matches, false otherwise"
    }
    
    crc16 = {
        description = "Computes a Dallas Semiconductor 16 bit CRC.  This is required to check the integrity of data received from many 1-Wire devices.  Note that the CRC computed here is **not** what you'll get from the 1-Wire network, for two reasons: , 1. The CRC is transmitted bitwise inverted. , 2. Depending on the endian-ness of your processor, the binary representation of the two-byte return value may have a different byte order than the two bytes you get from 1-Wire."
        syntax = "ow.crc16(buf[, crc])"
        parameters = "- buf string value, data to be calculated check sum in string , - crc CRC starting value (optional)"
        returns = "the CRC16 as defined by Dallas Semiconductor"
    }
    
    crc8 = {
        description = "Computes a Dallas Semiconductor 8 bit CRC, these are used in the ROM and scratchpad registers."
        syntax = "ow.crc8(buf)"
        parameters = "buf string value, data to be calculated check sum in string"
        returns = "CRC result as byte"
    }
    
    depower = {
        description = "Stops forcing power onto the bus. You only need to do this if you used the 'power' flag to ow.write() or used a ow.write_bytes() and aren't about to do another read or write."
        syntax = "ow.depower(pin)"
        parameters = "pin 1~12, I/O index"
        returns = "nil"
        seealso = "- [ow.write()](#owwrite) , - [ow.write_bytes()](#owwrite_bytes)"
    }
    
    read = {
        description = "Reads a byte."
        syntax = "ow.read(pin)"
        parameters = "pin 1~12, I/O index"
        returns = "byte read from slave device"
    }
    
    read_bytes = {
        description = "Reads multi bytes."
        syntax = "ow.read_bytes(pin, size)"
        parameters = "- pin 1~12, I/O index , - size number of bytes to be read from slave device"
        returns = "string bytes read from slave device"
    }
    
    reset = {
        description = "Performs a 1-Wire reset cycle."
        syntax = "ow.reset(pin)"
        parameters = "pin 1~12, I/O index"
        returns = "- 1 if a device responds with a presence pulse , - 0 if there is no device or the bus is shorted or otherwise held low for more than 250 µS"
    }
    
    reset_search = {
        description = "Clears the search state so that it will start from the beginning again."
        syntax = "ow.reset_search(pin)"
        parameters = "pin 1~12, I/O index"
        returns = "nil"
    }
    
    search = {
        description = "Looks for the next device."
        syntax = "ow.search(pin)"
        parameters = "pin 1~12, I/O index"
        returns = "rom_code string with length of 8 upon success. It contains the rom code of slave device. Returns nil if search was unsuccessful."
        seealso = "[ow.target_search()](#owtargetsearch)"
    }
    
    select = {
        description = "Issues a 1-Wire rom select command. Make sure you do the ow.reset(pin) first."
        syntax = "ow.select(pin, rom)"
        parameters = "- pin 1~12, I/O index , - rom string value, len 8, rom code of the salve device"
        returns = "nil"
        example = "lua , -- 18b20 Example , pin = 9 , ow.setup(pin) , count = 0 , repeat ,   count = count + 1 ,   addr = ow.reset_search(pin) ,   addr = ow.search(pin) ,   tmr.wdclr() , until (addr ~= nil) or (count > 100) , if addr == nil then ,   print("No more addresses.") , else ,   print(addr:byte(1,8)) ,   crc = ow.crc8(string.sub(addr,1,7)) ,   if crc == addr:byte(8) then ,     if (addr:byte(1) == 0x10) or (addr:byte(1) == 0x28) then ,       print("Device is a DS18S20 family device.") ,         repeat ,           ow.reset(pin) ,           ow.select(pin, addr) ,           ow.write(pin, 0x44, 1) ,           tmr.delay(1000000) ,           present = ow.reset(pin) ,           ow.select(pin, addr) ,           ow.write(pin,0xBE,1) ,           print("P="..present)   ,           data = nil ,           data = string.char(ow.read(pin)) ,           for i = 1, 8 do ,             data = data .. string.char(ow.read(pin)) ,           end ,           print(data:byte(1,9)) ,           crc = ow.crc8(string.sub(data,1,8)) ,           print("CRC="..crc) ,           if crc == data:byte(9) then ,              t = (data:byte(1) + data:byte(2) * 256) * 625 ,              t1 = t / 10000 ,              t2 = t % 10000 ,              print("Temperature="..t1.."."..t2.."Centigrade") ,           end                    ,           tmr.wdclr() ,         until false ,     else ,       print("Device family is not recognized.") ,     end ,   else ,     print("CRC is not valid!") ,   end , end , "
        seealso = "[ow.reset()](#owreset)"
    }
    
    setup = {
        description = "Sets a pin in onewire mode."
        syntax = "ow.setup(pin)"
        parameters = "pin 1~12, I/O index"
        returns = "nil"
    }
    
    skip = {
        description = "Issues a 1-Wire rom skip command, to address all on bus."
        syntax = "ow.skip(pin)"
        parameters = "pin 1~12, I/O index"
        returns = "nil"
    }
    
    target_search = {
        description = "Sets up the search to find the device type family_code. The search itself has to be initiated with a subsequent call to ow.search()."
        syntax = "ow.target_search(pin, family_code)"
        parameters = "- pin 1~12, I/O index , - family_code byte for family code"
        returns = "nil"
        seealso = "[ow.search()](#owsearch)"
    }
    
    write = {
        description = "Writes a byte. If power is 1 then the wire is held high at the end for parasitically powered devices. You are responsible for eventually depowering it by calling ow.depower() or doing another read or write."
        syntax = "ow.write(pin, v, power)"
        parameters = "- pin 1~12, I/O index , - v byte to be written to salve device  , - power 1 for wire being held high for parasitically powered devices"
        returns = "nil"
        seealso = "[ow.depower()](#owdepower)"
    }
    
    write_bytes = {
        description = "Writes multi bytes. If power is 1 then the wire is held high at the end for parasitically powered devices. You are responsible for eventually depowering it by calling ow.depower() or doing another read or write."
        syntax = "ow.write_bytes(pin, buf, power)"
        parameters = "- pin 1~12, IO index , - buf string to be written to slave device , - power 1 for wire being held high for parasitically powered devices"
        returns = "nil"
        seealso = "[ow.depower()](#owdepower)"
    }

}
perf = {
    
    start = {
        description = "Starts a performance monitoring session. "
        syntax = "perf.start([start[, end[, nbins[, offset]]]])"
        parameters = "- start (optional) The lowest PC address for the histogram. Default is 0x40000000. , - end (optional) The highest address for the histogram. Default is the end of the used space in the flash memory. , - nbins (optional) The number of bins in the histogram. Keep this reasonable otherwise  , you will run out of memory. Default is 1024. , - offset (Very optional) This specifies the offset of the saved PC value , on the interrupt stack. It appears that 20 is the correct value. , Note that the number of bins is an upper limit. The size of each bin is set to be the smallest power of two , such that the number of bins required is less than or equal to the provided number of bins."
        returns = "Nothing"
    }
    
    stop = {
        description = "Terminates a performance monitoring session and returns the histogram."
        syntax = "total, outside, histogram, binsize = perf.stop()"
        returns = "- total The total number of samples captured in this run , - outside The number of samples that were outside the histogram range , - histogram The histogram represented as a table indexed by address where the value is the number of samples. The address is the lowest address for the bin. , - binsize The number of bytes per histogram bin."
        example = "    perf.start() ,     for j = 0, 100 do ,       str = "str"..j ,     end ,     tot, out, tbl, binsize = perf.stop() ,     print(tot, out) ,     local keyset = {} ,     local n = 0 ,     for k,v in pairs(tbl) do ,       n=n+1 ,       keyset[n]=k ,     end ,     table.sort(keyset) ,     for kk,k in ipairs(keyset) do print(string.format("%x - %x",k, k + binsize - 1),tbl[k]) end , This runs a loop creating strings 100 times and then prints out the histogram (after sorting it). , This takes around 2,500 samples and provides a good indication of where all the CPU time is , being spent. "
    }

}
pwm = {
    
    close = {
        description = "Quit PWM mode for the specified GPIO pin."
        syntax = "pwm.close(pin)"
        parameters = "pin 1~12, IO index"
        returns = "nil"
        seealso = "[pwm.start()](#pwmstart)"
    }
    
    getclock = {
        description = "Get selected PWM frequency of pin."
        syntax = "pwm.getclock(pin)"
        parameters = "pin 1~12, IO index"
        returns = "number PWM frequency of pin"
        seealso = "[pwm.setclock()](#pwmsetclock)"
        seealso = "[pwm.getduty()](#pwmgetduty)"
    }
    
    getduty = {
        description = "Get selected duty cycle of pin."
        syntax = "pwm.getduty(pin)"
        parameters = "pin 1~12, IO index"
        returns = "number duty cycle, max 1023"
        seealso = "[pwm.setduty()](#pwmsetduty)"
    }
    
    setclock = {
        description = "Set PWM frequency. , **Note:** Setup of the PWM frequency will synchronously change other setups as well if there are any. Only one PWM frequency can be allowed for the system."
        syntax = "pwm.setclock(pin, clock)"
        parameters = "- pin 1~12, IO index , - clock 1~1000, PWM frequency"
        returns = "nil"
        seealso = "[pwm.getclock()](#pwmgetclock)"
    }
    
    setduty = {
        description = "Set duty cycle for a pin."
        syntax = "pwm.setduty(pin, duty)"
        parameters = "- pin 1~12, IO index , - duty 0~1023, pwm duty cycle, max 1023 (10bit)"
        returns = "nil"
        example = "lua , -- D1 is connected to green led , -- D2 is connected to blue led , -- D3 is connected to red led , pwm.setup(1, 500, 512) , pwm.setup(2, 500, 512) , pwm.setup(3, 500, 512) , pwm.start(1) , pwm.start(2) , pwm.start(3) , function led(r, g, b) ,     pwm.setduty(1, g) ,     pwm.setduty(2, b) ,     pwm.setduty(3, r) , end , led(512, 0, 0) --  set led to red , led(0, 0, 512) -- set led to blue."
    }
    
    setup = {
        description = "Set pin to PWM mode. Only 6 pins can be set to PWM mode at the most."
        syntax = "pwm.setup(pin, clock, duty)"
        parameters = "- pin 1~12, IO index , - clock 1~1000, pwm frequency , - duty 0~1023, pwm duty cycle, max 1023 (10bit)"
        returns = "nil"
        example = "lua , -- set pin index 1 as pwm output, frequency is 100Hz, duty cycle is half. , pwm.setup(1, 100, 512) , "
        seealso = "[pwm.start()](#pwmstart)"
    }
    
    start = {
        description = "PWM starts, the waveform is applied to the GPIO pin."
        syntax = "pwm.start(pin)"
        parameters = "pin 1~12, IO index"
        returns = "nil"
        seealso = "[pwm.stop()](#pwmstop)"
    }
    
    stop = {
        description = "Pause the output of the PWM waveform."
        syntax = "pwm.stop(pin)"
        parameters = "pin 1~12, IO index"
        returns = "nil"
        seealso = "[pwm.start()](#pwmstart)"
    }

}
rc = {

    }

}
rotary = {
    
    Sources = {
        description = "- Amazon: This [search](http://www.amazon.com/s/ref=nb_sb_noss_1?url=search-alias%3Dindustrial&field-keywords=rotary+encoder+push+button&rh=n%3A16310091%2Ck%3Arotary+encoder+push+button) shows a variety. , - Ebay: Somewhat cheaper in this [search](http://www.ebay.com/sch/i.html?_from=R40&_trksid=p2050601.m570.l1313.TR0.TRC0.H0.Xrotary+encoder+push+button.TRS0&_nkw=rotary+encoder+push+button&_sacat=0) , - Adafruit: [rotary encoder](https://www.adafruit.com/products/377) , - Aliexpress: This [search](http://www.aliexpress.com/wholesale?catId=0&initiative_id=SB_20160217173657&SearchText=rotary+encoder+push+button) reveals all sorts of shapes and sizes. , There is also a switch mounted on a board with standard 0.1" pins.  , This is the KY-040, and can also be found at [lots of places](https://www.google.com/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=ky-040%20rotary%20encoder).  , Note that the pins are named somewhat eccentrically, and I suspect that it really does need the VCC connected. , ####Constants , - rotary.PRESS = 1 The eventtype for the switch press. , - rotary.LONGPRESS = 2 The eventtype for a long press. , - rotary.RELEASE = 4 The eventtype for the switch release. , - rotary.TURN = 8 The eventtype for the switch rotation. , - rotary.CLICK = 16 The eventtype for a single click (after release) , - rotary.DBLCLICK = 32 The eventtype for a double click (after second release) , - rotary.ALL = 63 All event types."
    }
    
    setup = {
        description = "Initialize the nodemcu to talk to a rotary encoder switch."
        syntax = "rotary.setup(channel, pina, pinb[, pinpress[, longpress_time_ms[, dblclick_time_ms]]])"
        parameters = "- channel The rotary module supports three switches. The channel is either 0, 1 or 2. , - pina This is a GPIO number (excluding 0) and connects to pin phase A on the rotary switch. , - pinb This is a GPIO number (excluding 0) and connects to pin phase B on the rotary switch. , - pinpress (optional) This is a GPIO number (excluding 0) and connects to the press switch. , - longpress_time_ms (optional) The number of milliseconds (default 500) of press to be considered a long press. , - dblclick_time_ms (optional) The number of milliseconds (default 500) between a release and a press for the next release to be considered a double click."
        returns = "Nothing. If the arguments are in error, or the operation cannot be completed, then an error is thrown. , For all API calls, if the channel number is out of range, then an error will be thrown."
        example = "    rotary.setup(0, 5,6, 7)"
    }
    
    on = {
        description = "Sets a callback on specific events."
        syntax = "rotary.on(channel, eventtype[, callback])"
        parameters = "- channel The rotary module supports three switches. The channel is either 0, 1 or 2. , - eventtype This defines the type of event being registered. This is the logical or of one or more of PRESS, LONGPRESS, RELEASE, TURN, CLICK or DBLCLICK. , - callback This is a function that will be invoked when the specified event happens.  , If the callback is None or omitted, then the registration is cancelled. , The callback will be invoked with three arguments when the event happens. The first argument is the eventtype,  , the second is the current position of the rotary switch, and the third is the time when the event happened.  , The position is tracked , and is represented as a signed 32-bit integer. Increasing values indicate clockwise motion. The time is the number of microseconds represented , in a 32-bit integer. Note that this wraps every hour or so."
        example = "    rotary.on(0, rotary.ALL, function (type, pos, when)  ,       print "Position=" .. pos .. " event type=" .. type .. " time=" .. when ,     end) , #####Notes , Events will be delivered in order, but there may be missing TURN events. If there is a long  , queue of events, then PRESS and RELEASE events may also be missed. Multiple pending TURN events  , are typically dispatched as one TURN callback with the final position as its parameter. , Some switches have 4 steps per detent. This means that, in practice, the application , should divide the position by 4 and use that to determine the number of clicks. It is , unlikely that a switch will ever reach 30 bits of rotation in either direction -- some , are rated for under 50,000 revolutions. , The CLICK and LONGPRESS events are delivered on a timeout. The DBLCLICK event is delivered after a PRESS, RELEASE, PRESS, RELEASE sequence , where this is a short time gap between the middle RELEASE and PRESS. , #####Errors , If an invalid eventtype is supplied, then an error will be thrown."
    }
    
    getpos = {
        description = "Gets the current position and press status of the switch"
        syntax = "pos, press, queue = rotary.getpos(channel)"
        parameters = "- channel The rotary module supports three switches. The channel is either 0, 1 or 2."
        returns = "- pos The current position of the switch. , - press A boolean indicating if the switch is currently pressed. , - queue The number of undelivered callbacks (normally 0)."
        example = "    print rotary.getpos(0)"
    }
    
    close = {
        description = "Releases the resources associated with the rotary switch."
        syntax = "rotary.close(channel)"
        parameters = "- channel The rotary module supports three switches. The channel is either 0, 1 or 2."
        example = "    rotary.close(0)"
    }

}
rtcfifo = {
    
    dsleep_until_sample = {
        description = "When the rtcfifo module is compiled in together with the rtctime module, this convenience function is available. It allows for some measure of separation of concerns, enabling writing of modularized Lua code where a sensor reading abstraction may not need to be aware of the sample frequency (which is largely a policy decision, rather than an intrinsic of the sensor). Use of this function is effectively equivalent to [rtctime.dsleep_aligned(interval_us, minsleep_us)](rtctime.md#rtctimedsleep_aligned) where interval_us is what was given to [rtcfifo.prepare()](#rtcfifoprepare)."
        syntax = "rtcfifo.dsleep_until_sample(minsleep_us) , ####Parameter , minsleep_us minimum sleep time, in microseconds"
        example = "lua , -- deep sleep until it's time to take the next sample , rtcfifo.dsleep_until_sample(0) , "
        seealso = "[rtctime.dsleep_aligned()](rtctime.md#rtctimedsleep_aligned)"
    }
    
    peek = {
        description = "Reads a sample from the rtcfifo. An offset into the rtcfifo may be specified, but by default it reads the first sample (offset 0)."
        syntax = "rtcfifo.peek([offset])"
        parameters = "offset Peek at sample at position offset in the fifo. This is a relative offset, from the current head. Zero-based. Default value is 0."
        returns = "The values returned match the input arguments used to [rtcfifo.put()](#rtcfifoput). , - timestamp timestamp in seconds , - value the value , - neg_e scaling factor , - name sensor name , If no sample is available (at the specified offset), nothing is returned."
        example = "lua , local timestamp, value, neg_e, name = rtcfifo.peek()"
    }
    
    pop = {
        description = "Reads the first sample from the rtcfifo, and removes it from there."
        syntax = "rtcfifo.pop()"
        parameters = "none"
        returns = "The values returned match the input arguments used to [rtcfifo.put()](#rtcfifoput). , - timestamp timestamp in seconds , - value the value , - neg_e scaling factor , - name sensor name"
        example = "lua , while rtcfifo.count() > 0 do ,   local timestamp, value, neg_e, name = rtcfifo.pop() ,   -- do something with the sample, e.g. upload to somewhere , end"
    }
    
    prepare = {
        description = "Initializes the rtcfifo module for use. , Calling [rtcfifo.prepare()](#rtcfifoprepare) unconditionally re-initializes the storage - any samples stored are discarded."
        syntax = "rtcfifo.prepare([table])"
        parameters = "This function takes an optional configuration table as an argument. The following items may be configured: , - interval_us If wanting to make use of the [rtcfifo.sleep_until_sample()](#rtcfifosleep_until_sample) function, this field sets the sample interval (in microseconds) to use. It is effectively the first argument of [rtctime.dsleep_aligned()](rtctime.md#rtctimedsleep_aligned). , - sensor_count Specifies the number of different sensors to allocate name space for. This directly corresponds to a number of slots reserved for names in the variable block. The default value is 5, minimum is 1, and maximum is 16. , - storage_begin Specifies the first RTC user memory slot to use for the variable block. Default is 32. Only takes effect if storage_end is also specified. , - storage_end Specified the end of the RTC user memory slots. This slot number will *not* be touched. Default is 128. Only takes effect if storage_begin is also specified."
        returns = "nil"
        example = "lua , -- Initialize with default values , rtcfifo.prepare() ,  , lua , -- Use RTC slots 19 and up for variable storage , rtcfifo.prepare({storage_begin=21, storage_end=128}) , "
        seealso = "[rtcfifo.ready()](#rtcfifoready)"
        seealso = "[rtcfifo.prepare()](#rtcfifoprepare)"
    }
    
    put = {
        description = "Puts a sample into the rtcfifo. , If the rtcfifo has not been prepared, this function does nothing."
        syntax = "rtcfifo.put(timestamp, value, neg_e, name)"
        parameters = "- timestamp Timestamp in seconds. The timestamp would typically come from [rtctime.get()](rtctime.md#rtctimeget). , - value The value to store. , - neg_e The effective value stored is valueE<sup>neg_e</sup>. , - name Name of the sensor.  Only the first four (ASCII) characters of name are used. , Note that if the timestamp delta is too large compared to the previous sample stored, the rtcfifo evicts all earlier samples to store this one. Likewise, if name would mean there are more than the sensor_count (as specified to [rtcfifo.prepare()](#rtcfifoprepare)) names in use, the rtcfifo evicts all earlier samples."
        returns = "nil"
        example = "lua , -- Obtain a sample value from somewhere , local sample = ...  , -- Store sample with no scaling, under the name "foo" , rtcfifo.put(rtctime.get(), sample, 0, "foo")"
    }
    
    ready = {
        description = "Returns non-zero if the rtcfifo has been prepared and is ready for use, zero if not."
        syntax = "rtcfifo.ready()"
        parameters = "none"
        returns = "Non-zero if the rtcfifo has been prepared and is ready for use, zero if not."
        example = "lua , -- Prepare the rtcfifo if not already done , if not rtcfifo.ready() then ,   rtcfifo.prepare() , end , "
    }

}
rtcmem = {
    
    read32 = {
        description = "Reads one or more 32bit values from RTC user memory."
        syntax = "rtcmem.read32(idx [, num])"
        parameters = "  - idx zero-based index to start reading from ,   - num number of slots to read (default 1)"
        returns = "The value(s) read from RTC user memory. , If idx is outside the valid range [0,127] this function returns nothing. , If num results in overstepping the end of available memory, the function only returns the data from the valid slots."
        example = "lua , val = rtcmem.read32(0) -- Read the value in slot 0 , val1, val2 = rtcmem.read32(42, 2) -- Read the values in slots 42 and 43 , "
        seealso = "[rtcmem.write32()](#rtcmemwrite32)"
    }
    
    write32 = {
        description = "Writes one or more values to RTC user memory, starting at index idx. , Writing to indices outside the valid range [0,127] has no effect."
        syntax = "rtcmem.write32(idx, val [, val2, ...])"
        parameters = "  - idx zero-based index to start writing to. Auto-increments if multiple values are given. ,   - val value to store (32bit) ,   - val2... additional values to store (optional)"
        returns = "nil"
        example = "lua , rtcmem.write32(0, 53) -- Store the value 53 in slot 0 , rtcmem.write32(42, 2, 5, 7) -- Store the values 2, 5 and 7 into slots 42, 43 and 44, respectively. , "
        seealso = "[rtcmem.read32()](#rtcmemread32)"
    }

}
rtctime = {
    
    dsleep = {
        description = "Puts the ESP8266 into deep sleep mode, like [node.dsleep()](node.md#nodedsleep). It differs from [node.dsleep()](node.md#nodedsleep) in the following ways: , - Time is kept across the deep sleep. I.e. [rtctime.get()](#rtctimeget) will keep working (provided time was available before the sleep). , - This call never returns. The module is put to sleep immediately. This is both to support accurate time keeping and to reduce power consumption. , - The time slept will generally be considerably more accurate than with [node.dsleep()](node.md#nodedsleep). , - A sleep time of zero does not mean indefinite sleep, it is interpreted as a zero length sleep instead."
        syntax = "rtctime.dsleep(microseconds [, option])"
        parameters = "- microseconds number of microseconds to sleep for. Maxmium value is 4294967295us, or ~71 minutes. , - option sleep option, see [node.dsleep()](node.md#nodedsleep) for specifics."
        returns = "This function does not return."
        example = "lua , -- sleep for a minute , rtctime.dsleep(60*1000000) ,  , lua , -- sleep for 5 seconds, do not start RF on wakeup , rtctime.dsleep(5000000, 4)"
    }
    
    dsleep_aligned = {
        description = "For applications where it is necessary to take samples with high regularity, this function is useful. It provides an easy way to implement a "wake up on the next 5-minute boundary" scheme, without having to explicitly take into account how long the module has been active for etc before going back to sleep."
        syntax = "rtctime.dsleep(aligned_us, minsleep_us [, option])"
        parameters = "- aligned_us boundary interval in microseconds , - minsleep_us minimum time that will be slept, if necessary skipping an interval. This is intended for sensors where a sample reading is started before putting the ESP8266 to sleep, and then fetched upon wake-up. Here minsleep_us should be the minimum time required for the sensor to take the sample. , - option as with dsleep(), the option sets the sleep option, if specified."
        example = "lua , -- sleep at least 3 seconds, then wake up on the next 5-second boundary , rtctime.dsleep_aligned(5*1000000, 3*1000000)"
    }
    
    get = {
        description = "Returns the current time. If current time is not available, zero is returned."
        syntax = "rtctime.get()"
        parameters = "none"
        returns = "A two-value timestamp containing: , - sec seconds since the Unix epoch , - usec the microseconds part"
        example = "lua , sec, usec = rtctime.get() , "
        seealso = "[rtctime.set()](#rtctimeset)"
    }
    
    set = {
        description = "Sets the rtctime to a given timestamp in the Unix epoch (i.e. seconds from midnight 1970/01/01). If the module is not already keeping time, it starts now. If the module was already keeping time, it uses this time to help adjust its internal calibration values. Care is taken that timestamps returned from [rtctime.get()](#rtctimeget) *never go backwards*. If necessary, time is slewed and gradually allowed to catch up. , It is highly recommended that the timestamp is obtained via NTP (see [SNTP module](sntp.md)), GPS, or other highly accurate time source. , Values very close to the epoch are not supported. This is a side effect of keeping the memory requirements as low as possible. Considering that it's no longer 1970, this is not considered a problem."
        syntax = "rtctime.set(seconds, microseconds)"
        parameters = "- seconds the seconds part, counted from the Unix epoch , - microseconds the microseconds part"
        returns = "nil"
        example = "lua , -- Set time to 2015 July 9, 18:29:49 , rtctime.set(1436430589, 0) , "
        seealso = "[sntp.sync()](sntp.md#sntpsync)"
    }

}
sigma-delta = {
    
    close = {
        description = "Stops signal generation and reenables GPIO functionality at the specified pin."
        syntax = "sigma_delta.close(pin)"
        parameters = "pin 1~12, IO index"
        returns = "nil"
    }
    
    setprescale = {
        description = "Sets the prescale value."
        syntax = "sigma_delta.setprescale(value)"
        parameters = "value prescale 1 to 255"
        returns = "nil"
        seealso = "[sigma_delta.settarget()](#sigma_deltasettarget)"
    }
    
    setpwmduty = {
        description = "Operate the sigma-delta module in PWM-like mode with fixed base frequency."
        syntax = "sigma_delta.setpwmduty(ratio)"
        parameters = "ratio 0...255 for duty cycle 0...100%, 0 stops the signal at low"
        returns = "nil"
        example = "lua , -- attach generator to pin 2 , sigma_delta.setup(2) , -- set 50% duty cycle ratio (and implicitly start signal) , sigma_delta.setpwmduty(128) , -- stop , sigma_delta.setpwmduty(0) , -- resume with ~99.6% ratio , sigma_delta.setpwmduty(255) , -- stop and detach generator from pin 2 , sigma_delta.close(2)"
    }
    
    settarget = {
        description = "Sets the target value."
        syntax = "sigma_delta.settarget(value)"
        parameters = "value target 0 to 255"
        returns = "nil"
        seealso = "[sigma_delta.setprescale()](#sigma_deltasetprescale)"
    }
    
    setup = {
        description = "Stops the signal generator and routes it to the specified pin."
        syntax = "sigma_delta.setup(pin)"
        parameters = "pin 1~12, IO index"
        returns = "nil"
    }

}
sntp = {
    
    sync = {
        description = "Attempts to obtain time synchronization."
        syntax = "sntp.sync([server_ip], [callback], [errcallback])"
        parameters = "- server_ip if non-nil, that server is used. If nil, then the last contacted server is used. This ties in with the NTP anycast mode, where the first responding server is remembered for future synchronization requests. The easiest way to use anycast is to always pass nil for the server argument. , - callback if provided it will be invoked on a successful synchronization, with three parameters: seconds, microseconds, and server. Note that when the [rtctime](rtctime.md) module is available, there is no need to explicitly call [rtctime.set()](rtctime.md#rtctimeset) - this module takes care of doing so internally automatically, for best accuracy. , - errcallback failure callback with a single integer parameter describing the type of error. The module automatically performs a number of retries before giving up and reporting the error. Error codes: ,   - 1: DNS lookup failed ,   - 2: Memory allocation failure ,   - 3: UDP send failed ,   - 4: Timeout, no NTP response received"
        returns = "nil"
        example = "lua , -- Best effort, use the last known NTP server (or the NTP "anycast" address 224.0.1.1 initially) , sntp.sync() ,  , lua , -- Sync time with 192.168.0.1 and print the result, or that it failed , sntp.sync('192.168.0.1', ,   function(sec,usec,server) ,     print('sync', sec, usec, server) ,   end, ,   function() ,    print('failed!') ,   end , ) , "
        seealso = "[rtctime.set()](rtctime.md#rtctimeset)"
    }

}
spi = {
    
    recv = {
        description = "Receive data from SPI."
        syntax = "spi.recv(id, size[, default_data])"
        parameters = "- id SPI ID number: 0 for SPI, 1 for HSPI , - size number of data items to be read , - default_data default data being sent on MOSI (all-1 if omitted)"
        returns = "String containing the bytes read from SPI."
        seealso = "[spi.send()](#spisend)"
    }
    
    send = {
        description = "Send data via SPI in half-duplex mode. Send & receive data in full-duplex mode."
        syntax = "HALFDUPLEX:<br /> , wrote = spi.send(id, data1[, data2[, ..., datan]]) , FULLDUPLEX:<br /> , wrote[, rdata1[, ..., rdatan]] = spi.send(id, data1[, data2[, ..., datan]])"
        parameters = "- id SPI ID number: 0 for SPI, 1 for HSPI , - data data can be either a string, a table or an integer number.<br/>Each data item is considered with databits number of bits."
        returns = "- wrote number of written bytes , - rdata received data when configured with spi.FULLDUPLEX<br />Same data type as corresponding data parameter."
        example = "lua , =spi.send(1, 0, 255, 255, 255) , 4       255     192     32      0 , x = {spi.send(1, 0, 255, 255, 255)} , =x[1] , 4 , =x[2] , 255 , =x[3] , 192 , =x[4] , 32 , =x[5] , 0 , =x[6] , nil , =#x , 5 , _, _, x = spi.send(1, 0, {255, 255, 255}) , =x[1] , 192 , =x[2] , 32 , =x[3] , 0 , "
        seealso = "- [spi.setup()](#spisetup) , - [spi.recv()](#spirecv)"
    }
    
    setup = {
        description = "Set up the SPI configuration. , Refer to [Serial Peripheral Interface Bus](https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus#Clock_polarity_and_phase) for details regarding the clock polarity and phase definition."
        syntax = "spi.setup(id, mode, cpol, cpha, databits, clock_div[, duplex_mode])"
        parameters = "- id SPI ID number: 0 for SPI, 1 for HSPI , - mode select master or slave mode , 	- spi.MASTER , 	- spi.SLAVE - **not supported currently** , - cpol clock polarity selection , 	- spi.CPOL_LOW  , 	- spi.CPOL_HIGH , - cpha clock phase selection , 	- spi.CPHA_LOW , 	- spi.CPHA_HIGH , - databits number of bits per data item 1 - 32 , - clock_div SPI clock divider, f(SPI) = f(CPU) / clock_div , - duplex_mode duplex mode , 	-  spi.HALFDUPLEX (default when omitted) , 	- spi.FULLDUPLEX"
        returns = "Number: 1 , ####Low Level Hardware Functions , The low level functions provide a hardware-centric API for application , scenarios that need to excercise more complex SPI transactions. The , programming model is built up around the HW send and receive buffers and SPI , transactions are initiated with full control over the hardware features."
    }
    
    get_miso = {
        description = "Extract data items from MISO buffer after spi.transaction()."
        syntax = "data1[, data2[, ..., datan]] = spi.get_miso(id, offset, bitlen, num)"
        parameters = "- id SPI ID number: 0 for SPI, 1 for HSPI , - offset bit offset into MISO buffer for first data item , - bitlen bit length of a single data item , - num number of data items to retrieve"
        returns = "num data items"
        seealso = "[spi.transaction()](#spitransaction)"
    }
    
    set_mosi = {
        description = "Insert data items into MOSI buffer for spi.transaction()."
        syntax = "spi.set_mosi(id, offset, bitlen, data1[, data2[, ..., datan]])"
        parameters = "- id SPI ID number: 0 for SPI, 1 for HSPI , - offset bit offset into MOSI buffer for inserting data1 and subsequent items , - bitlen bit length of data1, data2, ... , - data data items where bitlen number of bits are considered for the transaction."
        returns = "nil"
        seealso = "[spi.transaction()](#spitransaction)"
    }
    
    transaction = {
        description = "Start an SPI transaction, consisting of up to 5 phases: , 1. Command , 2. Address , 3. MOSI , 4. Dummy , 5. MISO"
        syntax = "spi.transaction(id, cmd_bitlen, cmd_data, addr_bitlen, addr_data, mosi_bitlen, dummy_bitlen, miso_bitlen)"
        parameters = "- id SPI ID number: 0 for SPI, 1 for HSPI , - cmd_bitlen bit length of the command phase (0 - 16) , - cmd_data data for command phase , - addr_bitlen bit length for address phase (0 - 32) , - addr_data data for command phase , - mosi_bitlen bit length of the MOSI phase (0 - 512) , - dummy_bitlen bit length of the dummy phase (0 - 256) , - miso_bitlen bit length of the MISO phase (0 - 512) for half-duplex.<br />Full-duplex mode is activated with a negative value."
        returns = "nil"
        seealso = "- [spi.set_mosi()](#spisetmosi) , - [spi.get_miso()](#spigetmiso)"
    }

}
struct = {

        example = "To pack and unpack the structure ,         struct Str { ,           char b; ,           int i[4]; ,         }; , you can use the string "<!4biiii". , To pack a string with its length coded in its first byte, use the , following code: ,         x = struct.pack("Bc0", string.len(s), s) , To unpack that string, do as follows: ,         s = struct.unpack("Bc0", x) , Note that the length (read by the element "B") is not returned. , To pack a string in a fixed-width field of 10 characters padded with , blanks, do as follows: ,         x = struct.pack("c10", s .. string.rep(" ", 10)) ,     
    pack = {
        description = "Returns a string containing the values d1, d2, etc. packed , according to the format string fmt."
        syntax = "struct.pack (fmt, d1, d2, ...)"
        parameters = "- fmt The format string in the format above , - d1 The first data item to be packed , - d2 The second data item to be packed etc."
        returns = "The packed string."
        example = " , s = struct.pack("I", 0x41424344) , print(s)"
    }
    
    unpack = {
        description = "Returns the values packed in string s according to the format , string fmt. An optional i marks where in s to start reading , (default is 1). After the read values, this function also returns , the index in s where it stopped reading, which is also where you , should start to read the rest of the string."
        syntax = "struct.unpack (fmt, s[, offset])"
        parameters = "- fmt The format string in the format above , - s The string holding the data to be unpacked , - offset The position to start in the string (default is 1)"
        returns = "All the unpacked data."
        example = "Suppose we have to decode a string s with an unknown number of , doubles; the end is marked by a zero value. We can use the following , code: ,         local a = {} ,         local i = 1         -- index where to read ,         while true do ,           local d ,           d, i = struct.unpack("d", s, i) ,           if d == 0 then break end ,           a[#a + 1] = d ,         end"
    }
    
    size = {
        description = "Returns the size of a string formatted according to the format , string fmt. The format string should contain neither the option , s nor the option c0."
        syntax = "struct.size (fmt)"
        parameters = "- fmt The format string in the format above"
        returns = "The size of the string that would be output in a pack operation with this format string."
        example = " , print(struct.size("i")) ,  , This prints the size of the native integer type. , ####License , This package is distributed under the MIT license. See copyright notice , at the end of file struct.c."
    }

}
tmr = {
    
    alarm = {
        description = "This is a convenience function combining [tmr.register()](#tmrregister) and [tmr.start()](#tmrstart) into a single call. , To free up the resources with this timer when done using it, call [tmr.unregister()](#tmrunregister) on it. For one-shot timers this is not necessary, unless they were stopped before they expired."
        parameters = "- id timer id (0-6) , - interval_ms timer interval in milliseconds. Maximum value is 6870947 (1:54:30.947). , - mode timer mode: , 	- tmr.ALARM_SINGLE a one-shot alarm (and no need to call [tmr.unregister()](#tmrunregister)) , 	- tmr.ALARM_SEMI manually repeating alarm (call [tmr.start()](#tmrstart) to restart) , 	- tmr.ALARM_AUTO automatically repeating alarm"
        returns = "true if the timer was started, false on error"
        example = "lua , if not tmr.alarm(0, 5000, tmr.ALARM_SINGLE, function() print("hey there") end) then print("whoopsie") end , "
        seealso = "- [tmr.register()](#tmrregister) , - [tmr.start()](#tmrstart) , - [tmr.unregister()](#tmrunregister)"
    }
    
    delay = {
        description = "Busyloops the processor for a specified number of microseconds. , This is in general a **bad** idea, because nothing else gets to run, and the networking stack (and other things) can fall over as a result. The only time tmr.delay() may be appropriate to use is if dealing with a peripheral device which needs a (very) brief delay between commands, or similar. *Use with caution!* , Also note that the actual amount of time delayed for may be noticeably greater, both as a result of timing inaccuracies as well as interrupts which may run during this time."
        syntax = "tmr.delay(us)"
        parameters = "us microseconds to busyloop for"
        returns = "nil"
        example = "lua , tmr.delay(100)"
    }
    
    interval = {
        description = "Changes a registered timer's expiry interval."
        syntax = "tmr.interval(id, interval_ms)"
        parameters = "- id timer id (0-6) , - interval_ms new timer interval in milliseconds. Maximum value is 6870947 (1:54:30.947)."
        returns = "nil"
        example = "lua , tmr.register(0, 5000, tmr.ALARM_SINGLE, function() print("hey there") end) , tmr.interval(0, 3000) -- actually, 3 seconds is better!"
    }
    
    now = {
        description = "Returns the system counter, which counts in microseconds. Limited to 31 bits, after that it wraps around back to zero. That is essential if you use this function to [debounce or throttle GPIO input](https://github.com/hackhitchin/esp8266-co-uk/issues/2)."
        syntax = "tmr.now()"
        parameters = "none"
        returns = "the current value of the system counter"
        example = "lua , print(tmr.now()) , print(tmr.now())"
    }
    
    register = {
        description = "Configures a timer and registers the callback function to call on expiry. , To free up the resources with this timer when done using it, call [tmr.unregister()](#tmrunregister) on it. For one-shot timers this is not necessary, unless they were stopped before they expired."
        syntax = "tmr.register(id, interval_ms, mode, func)"
        parameters = "- id timer id (0-6) , - interval_ms timer interval in milliseconds. Maximum value is 6870947 (1:54:30.947). , - mode timer mode: , 	- tmr.ALARM_SINGLE a one-shot alarm (and no need to call [tmr.unregister()](#tmrunregister)) , 	- tmr.ALARM_SEMI manually repeating alarm (call [tmr.start()](#tmrunregister) to restart) , 	- tmr.ALARM_AUTO automatically repeating alarm , Note that registering does *not* start the alarm."
        returns = "nil"
        example = "lua , tmr.register(0, 5000, tmr.ALARM_SINGLE, function() print("hey there") end) , tmr.start(0) , "
        seealso = "[tmr.alarm()](#tmralarm)"
    }
    
    softwd = {
        description = "Provides a simple software watchdog, which needs to be re-armed or disabled before it expires, or the system will be restarted."
        syntax = "tmr.softwd(timeout_s)"
        parameters = "timeout_s watchdog timeout, in seconds. To disable the watchdog, use -1 (or any other negative value)."
        returns = "nil"
        example = "lua , function on_success_callback() ,   tmr.softwd(-1) ,   print("Complex task done, soft watchdog disabled!") , end , tmr.softwd(5) , -- go off and attempt to do whatever might need a restart to recover from , complex_stuff_which_might_never_call_the_callback(on_success_callback)"
    }
    
    start = {
        description = "Starts or restarts a previously configured timer."
        syntax = "tmr.start(id)"
        parameters = "id timer id (0-6)"
        returns = "true if the timer was started, false on error"
        example = "lua , tmr.register(0, 5000, tmr.ALARM_SINGLE, function() print("hey there") end) , if not tmr.start(0) then print("uh oh") end , "
        seealso = "- [tmr.register()](#tmrregister) , - [tmr.stop()](#tmrstop) , - [tmr.unregister()](#tmrunregister)"
    }
    
    state = {
        description = "Checks the state of a timer."
        syntax = "tmr.state(id)"
        parameters = "id timer id (0-6)"
        returns = "(bool, int) or nil , If the specified timer is registered, returns whether it is currently started and its mode. If the timer is not registered, nil is returned."
        example = "lua , running, mode = tmr.state(0)"
    }
    
    stop = {
        description = "Stops a running timer, but does *not* unregister it. A stopped timer can be restarted with [tmr.start()](#tmrstart)."
        syntax = "tmr.stop(id)"
        parameters = "id timer id (0-6)"
        returns = "true if the timer was stopped, false on error"
        example = "lua , if not tmr.stop(2) then print("timer 2 not stopped, not registered?") end , "
        seealso = "- [tmr.register()](#tmrregister) , - [tmr.stop()](#tmrstop) , - [tmr.unregister()](#tmrunregister)"
    }
    
    time = {
        description = "Returns the system uptime, in seconds. Limited to 31 bits, after that it wraps around back to zero."
        syntax = "tmr.time()"
        parameters = "none"
        returns = "the system uptime, in seconds, possibly wrapped around"
        example = "lua , print("Uptime (probably):", tmr.time())"
    }
    
    unregister = {
        description = "Stops the timer (if running) and unregisters the associated callback. , This isn't necessary for one-shot timers (tmr.ALARM_SINGLE), as those automatically unregister themselves when fired."
        syntax = "tmr.unregister(id)"
        parameters = "id timer id (0-6)"
        returns = "nil"
        example = "lua , tmr.unregister(0) , "
        seealso = "[tmr.register()](#tmrregister)"
    }
    
    wdclr = {
        description = "Feed the system watchdog. , *In general, if you ever need to use this function, you are doing it wrong.* , The event-driven model of NodeMCU means that there is no need to be sitting in hard loops waiting for things to occur. Rather, simply use the callbacks to get notified when somethings happens. With this approach, there should never be a need to manually feed the system watchdog."
        syntax = "tmr.wdclr()"
        parameters = "none"
        returns = "nil"
    }

}
tsl2561 = {
    
    getlux = {
        description = "Reads sensor values from the device and returns calculated lux value."
        syntax = "tsl2561.getlux()"
        parameters = "none"
        returns = "- lux the calculated illuminance in lux (lx) , - status value indicating success or failure as explained below: ,     * tsl2561.TSL2561_OK ,     * tsl2561.TSL2561_ERROR_I2CINIT can't initialize I²C bus ,     * tsl2561.TSL2561_ERROR_I2CBUSY I²C bus busy ,     * tsl2561.TSL2561_ERROR_NOINIT initialize I²C bus before calling function ,     * tsl2561.TSL2561_ERROR_LAST"
        example = " lua , status = tsl2561.init(5, 6, tsl2561.ADDRESS_FLOAT, tsl2561.PACKAGE_T_FN_CL) , if status == tsl2561.TSL2561_OK then ,     lux = tsl2561.getlux() ,     print("Illuminance: "..lux.." lx")  , end"
    }
    
    getrawchannels = {
        description = "Reads the device's 2 sensors and returns their values."
        syntax = "tsl2561.getrawchannels()"
        parameters = "none"
        returns = "- ch0 value of the broad spectrum sensor , - ch1 value of the IR sensor , - status value indicating success or failure as explained below: ,     * tsl2561.TSL2561_OK ,     * tsl2561.TSL2561_ERROR_I2CINIT can't initialize I²C bus ,     * tsl2561.TSL2561_ERROR_I2CBUSY I²C bus busy ,     * tsl2561.TSL2561_ERROR_NOINIT initialize I²C bus before calling function ,     * tsl2561.TSL2561_ERROR_LAST"
        example = " lua , status = tsl2561.init(5, 6, tsl2561.ADDRESS_FLOAT, tsl2561.PACKAGE_T_FN_CL) , if status == tsl2561.TSL2561_OK then ,     ch0, ch1 = tsl2561.getrawchannels() ,     print("Raw values: "..ch0, ch1) ,     lux = tsl2561.getlux() ,     print("Illuminance: "..lux.." lx")  , end"
    }
    
    init = {
        description = "Initializes the device on pins sdapin & sclpin. Optionally also configures the devices address and package. Default: address pin floating (0x39) and FN package."
        syntax = " tsl2561.init(sdapin, sclpin[, address[, package]])"
        parameters = "- sdapin pin number of the device's I²C sda connection , - sclpin pin number of the device's I²C scl connection , - address optional address of the device on the I²C bus ,     * tsl2561.ADDRESS_GND ,     * tsl2561.ADDRESS_FLOAT (default when omitted) ,     * tsl2561.ADDRESS_VDD , - package optional device's package type (slight difference in lux calculation) ,     * tsl2561.PACKAGE_CS ,     * tsl2561.PACKAGE_T_FN_CL (default when omitted)"
        returns = "status value indicating success or failure as explained below: , - tsl2561.TSL2561_OK , - tsl2561.TSL2561_ERROR_I2CINIT can't initialize I²C bus , - tsl2561.TSL2561_ERROR_I2CBUSY I²C bus busy , - tsl2561.TSL2561_ERROR_NOINIT Initialize I²C bus before calling function , - tsl2561.TSL2561_ERROR_LAST"
        example = " lua , status = tsl2561.init(5, 6, tsl2561.ADDRESS_FLOAT, tsl2561.PACKAGE_T_FN_CL) , if status == tsl2561.TSL2561_OK then ,     lux = tsl2561.getlux() ,     print("Illuminance: "..lux.." lx")  , end"
    }
    
    settiming = {
        description = "Sets the integration time and gain settings of the device. When tls2561.init() is called, these values default to 402 ms and no gain."
        syntax = "tsl2561.settiming(integration, gain)"
        parameters = "- integration sets the device's integration period. Valid options are: ,     * tsl2561.INTEGRATIONTIME_13MS ,     * tsl2561.INTEGRATIONTIME_101MS ,     * tsl2561.INTEGRATIONTIME_402MS (default when omitted) , - gain sets the device's gain. Valid options are: ,     * tsl2561.GAIN_1X (default when omitted) ,     * tsl2561.GAIN_16X"
        returns = "status value indicating success or failure as explained below: , - tsl2561.TSL2561_OK , - tsl2561.TSL2561_ERROR_I2CINIT can't initialize I²C bus , - tsl2561.TSL2561_ERROR_I2CBUSY I²C bus busy , - tsl2561.TSL2561_ERROR_NOINIT initialize I²C bus before calling function , - tsl2561.TSL2561_ERROR_LAST"
        example = " lua , status = tsl2561.init(5, 6, tsl2561.ADDRESS_FLOAT, tsl2561.PACKAGE_T_FN_CL) , if status == tsl2561.TSL2561_OK then ,     status = tsl2561.settiming(tsl2561.INTEGRATIONTIME_101MS, tsl2561.GAIN_16X) , end , if status == tsl2561.TSL2561_OK then ,     lux = tsl2561.getlux() ,     print("Illuminance: "..lux.." lx")  , end , "
    }

}
u8g = {
    sh1106_128x64_i2c = {
        description = "Initialize a display via I²C. , The init sequence would insert delays to match the display specs. These can destabilize the overall system if wifi service is blocked for too long. It is therefore advisable to disable such delays unless the specific use case can exclude wifi traffic while initializing the display driver."
        syntax = "(u8g.sh1106_128x64_i2c(address[, use_delay])"
        parameters = "- address I²C slave address of display , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , sda = 5 , scl = 6 , i2c.setup(0, sda, scl, i2c.SLOW) , sla = 0x3c , disp = u8g.sh1106_128x64_i2c(sla) , "
        seealso = "[SPI Display Drivers](#spi-display-drivers)"
    }
    
    ssd1306_128x64_i2c = {
        description = "Initialize a display via I²C. , The init sequence would insert delays to match the display specs. These can destabilize the overall system if wifi service is blocked for too long. It is therefore advisable to disable such delays unless the specific use case can exclude wifi traffic while initializing the display driver."
        syntax = "(u8g.ssd1306_128x64_i2c(address[, use_delay])"
        parameters = "- address I²C slave address of display , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , sda = 5 , scl = 6 , i2c.setup(0, sda, scl, i2c.SLOW) , sla = 0x3c , disp = u8g.ssd1306_128x64_i2c(sla) , "
        seealso = "[SPI Display Drivers](#spi-display-drivers)"
    }
    
    ssd1306_64x48_i2c = {
        description = "Initialize a display via I²C. , The init sequence would insert delays to match the display specs. These can destabilize the overall system if wifi service is blocked for too long. It is therefore advisable to disable such delays unless the specific use case can exclude wifi traffic while initializing the display driver."
        syntax = "(u8g.ssd1306_64x48_i2c(address[, use_delay])"
        parameters = "- address I²C slave address of display , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , sda = 5 , scl = 6 , i2c.setup(0, sda, scl, i2c.SLOW) , sla = 0x3c , disp = u8g.ssd1306_64x48_i2c(sla) , "
        seealso = "[SPI Display Drivers](#spi-display-drivers)"
    }
    
    ssd1309_128x64_i2c = {
        description = "Initialize a display via I²C. , The init sequence would insert delays to match the display specs. These can destabilize the overall system if wifi service is blocked for too long. It is therefore advisable to disable such delays unless the specific use case can exclude wifi traffic while initializing the display driver."
        syntax = "(u8g.ssd1309_128x64_i2c(address[, use_delay])"
        parameters = "- address I²C slave address of display , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , sda = 5 , scl = 6 , i2c.setup(0, sda, scl, i2c.SLOW) , sla = 0x3c , disp = u8g.ssd1309_128x64_i2c(sla) , "
        seealso = "[SPI Display Drivers](#spi-display-drivers)"
    }
    
    ssd1327_96x96_gr_i2c = {
        description = "Initialize a display via I²C. , The init sequence would insert delays to match the display specs. These can destabilize the overall system if wifi service is blocked for too long. It is therefore advisable to disable such delays unless the specific use case can exclude wifi traffic while initializing the display driver."
        syntax = "(u8g.ssd1327_96x96_gr_i2c(address[, use_delay])"
        parameters = "- address I²C slave address of display , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , sda = 5 , scl = 6 , i2c.setup(0, sda, scl, i2c.SLOW) , sla = 0x3c , disp = u8g.ssd1327_96x96_gr_i2c(sla) , "
        seealso = "[SPI Display Drivers](#spi-display-drivers)"
    }
    
    uc1611_dogm240_i2c = {
        description = "Initialize a display via I²C. , The init sequence would insert delays to match the display specs. These can destabilize the overall system if wifi service is blocked for too long. It is therefore advisable to disable such delays unless the specific use case can exclude wifi traffic while initializing the display driver."
        syntax = "(u8g.uc1611_dogm240_i2c(address[, use_delay])"
        parameters = "- address I²C slave address of display , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , sda = 5 , scl = 6 , i2c.setup(0, sda, scl, i2c.SLOW) , sla = 0x3c , disp = u8g.uc1611_dogm240_i2c(sla) , "
        seealso = "[SPI Display Drivers](#spi-display-drivers)"
    }
    
    uc1611_dogxl240_i2c = {
        description = "Initialize a display via I²C. , The init sequence would insert delays to match the display specs. These can destabilize the overall system if wifi service is blocked for too long. It is therefore advisable to disable such delays unless the specific use case can exclude wifi traffic while initializing the display driver."
        syntax = "(u8g.uc1611_dogxl240_i2c(address[, use_delay])"
        parameters = "- address I²C slave address of display , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , sda = 5 , scl = 6 , i2c.setup(0, sda, scl, i2c.SLOW) , sla = 0x3c , disp = u8g.uc1611_dogxl240_i2c(sla) , "
        seealso = "[SPI Display Drivers](#spi-display-drivers)"
    }

    ld7032_60x32_hw_spi = {
        syntax = "u8g.ld7032_60x32_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ld7032_60x32_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    pcd8544_84x48_hw_spi = {
        syntax = "u8g.pcd8544_84x48_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.pcd8544_84x48_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    pcf8812_96x65_hw_spi = {
        syntax = "u8g.pcf8812_96x65_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.pcf8812_96x65_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    sh1106_128x64_hw_spi = {
        syntax = "u8g.sh1106_128x64_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.sh1106_128x64_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"
    }
   
    ssd1306_128x64_hw_spi = {
        syntax = "u8g.ssd1306_128x64_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1306_128x64_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1306_64x48_hw_spi = {
        syntax = "u8g.ssd1306_64x48_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1306_64x48_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1309_128x64_hw_spi = {
        syntax = "u8g.ssd1309_128x64_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1309_128x64_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1322_nhd31oled_bw_hw_spi = {
        syntax = "u8g.ssd1322_nhd31oled_bw_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1322_nhd31oled_bw_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1322_nhd31oled_gr_hw_spi = {
        syntax = "u8g.ssd1322_nhd31oled_gr_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1322_nhd31oled_gr_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1325_nhd27oled_bw_hw_spi = {
        syntax = "u8g.ssd1325_nhd27oled_bw_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1325_nhd27oled_bw_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1325_nhd27oled_gr_hw_spi = {
        syntax = "u8g.ssd1325_nhd27oled_gr_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1325_nhd27oled_gr_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1327_96x96_gr_hw_spi = {
        syntax = "u8g.ssd1327_96x96_gr_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1327_96x96_gr_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1351_128x128_332_hw_spi = {
        syntax = "u8g.ssd1351_128x128_332_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1351_128x128_332_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1351_128x128gh_332_hw_spi = {
        syntax = "u8g.ssd1351_128x128gh_332_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1351_128x128gh_332_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1351_128x128_hicolor_hw_spi = {
        syntax = "u8g.ssd1351_128x128_hicolor_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1351_128x128_hicolor_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1351_128x128gh_hicolor_hw_spi = {
        syntax = "u8g.ssd1351_128x128gh_hicolor_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1351_128x128gh_hicolor_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1353_160x128_332_hw_spi = {
        syntax = "u8g.ssd1353_160x128_332_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1353_160x128_332_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    ssd1353_160x128_hicolor_hw_spi = {
        syntax = "u8g.ssd1353_160x128_hicolor_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.ssd1353_160x128_hicolor_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    st7565_64128n_hw_spi = {
        syntax = "u8g.st7565_64128n_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.st7565_64128n_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    st7565_dogm128_hw_spi = {
        syntax = "u8g.st7565_dogm128_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.st7565_dogm128_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    st7565_dogm128_hw_spi = {
        syntax = "u8g.st7565_dogm128_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.st7565_dogm128_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    st7565_lm6059_hw_spi = {
        syntax = "u8g.st7565_lm6059_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.st7565_lm6059_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    st7565_lm6063_hw_spi = {
        syntax = "u8g.st7565_lm6063_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.st7565_lm6063_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    st7565_nhd_c12832_hw_spi = {
        syntax = "u8g.st7565_nhd_c12832_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.st7565_nhd_c12832_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    st7565_nhd_c12864_hw_spi = {
        syntax = "u8g.st7565_nhd_c12864_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.st7565_nhd_c12864_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    uc1601_c128032_hw_spi = {
        syntax = "u8g.uc1601_c128032_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.uc1601_c128032_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    uc1608_240x128_hw_spi = {
        syntax = "u8g.uc1608_240x128_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.uc1608_240x128_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    uc1608_240x64_hw_spi = {
        syntax = "u8g.uc1608_240x64_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.uc1608_240x64_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    uc1610_dogxl160_bw_hw_spi = {
        syntax = "u8g.uc1610_dogxl160_bw_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.uc1610_dogxl160_bw_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    uc1610_dogxl160_gr_hw_spi = {
        syntax = "u8g.uc1610_dogxl160_gr_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.uc1610_dogxl160_gr_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    uc1611_dogm240_hw_spi = {
        syntax = "u8g.uc1611_dogm240_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.uc1611_dogm240_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    uc1611_dogxl240_hw_spi = {
        syntax = "u8g.uc1611_dogxl240_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.uc1611_dogxl240_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    uc1701_dogs102_hw_spi = {
        syntax = "u8g.uc1701_dogs102_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.uc1701_dogs102_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
   
    uc1701_mini12864_hw_spi = {
        syntax = "u8g.uc1701_mini12864_hw_spi(cs, dc[, res[, use_delay]])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES, none if omitted , - use_delay '1': use delays in init sequence, '0' if omitted"
        returns = "u8g display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, 8, 8) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = u8g.uc1701_mini12864_hw_spi(cs, dc, res) , "
        seealso = "[I²C Display Drivers](#i2c-display-drivers) , ___ , ####Constants , Constants for various functions. , u8g.DRAW_UPPER_RIGHT, u8g.DRAW_UPPER_LEFT, u8g.DRAW_LOWER_RIGHT, u8g.DRAW_LOWER_LEFT, u8g.DRAW_ALL, , u8g.MODE_BW, u8g.MODE_GRAY2BIT , u8g.font_6x10, ... , ####u8g.disp Sub-Module"   
    }
    
    disp:begin = {
        description = "See [u8glib begin()](https://github.com/olikraus/u8glib/wiki/userreference#begin)."
    }
    
    disp:drawBitmap = {
        description = "Draw a bitmap at the specified x/y position (upper left corner of the bitmap). , Parts of the bitmap may be outside the display boundaries. The bitmap is specified by the array bitmap. A cleared bit means: Do not draw a pixel. A set bit inside the array means: Write pixel with the current color index. For a monochrome display, the color index 0 will usually clear a pixel and the color index 1 will set a pixel."
        syntax = "disp:drawBitmap(x, y, cnt, h, bitmap)"
        parameters = "- x X-position (left position of the bitmap) , - y Y-position (upper position of the bitmap) , - cnt number of bytes of the bitmap in horizontal direction. The width of the bitmap is cnt*8. , - h height of the bitmap , - bitmap bitmap data supplied as string"
        returns = "nil"
        seealso = "- [u8glib drawBitmap()](https://github.com/olikraus/u8glib/wiki/userreference#drawbitmap) , - [lua_examples/u8glib/u8g_bitmaps.lua](https://github.com/nodemcu/nodemcu-firmware/blob/master/lua_examples/u8glib/u8g_bitmaps.lua) , - [u8g.disp:drawXBM()](#u8gdispdrawxbm)"
    }
    
    disp:drawBox = {
        description = "See [u8glib drawBox()](https://github.com/olikraus/u8glib/wiki/userreference#drawbox)."
    }
    
    disp:drawCircle = {
        description = "See [u8glib drawCircle()](https://github.com/olikraus/u8glib/wiki/userreference#drawcircle)."
    }
    
    disp:drawDisc = {
        description = "See [u8glib drawDisc()](https://github.com/olikraus/u8glib/wiki/userreference#drawdisc)."
    }
    
    disp:drawEllipse = {
        description = "See [u8glib drawEllipse()](https://github.com/olikraus/u8glib/wiki/userreference#drawellipse)."
    }
    
    disp:drawFilledEllipse = {
        description = "See [u8glib drawFilledEllipse](https://github.com/olikraus/u8glib/wiki/userreference#drawfilledellipse)."
    }
    
    disp:drawFrame = {
        description = "See [u8glib drawFrame()](https://github.com/olikraus/u8glib/wiki/userreference#drawframe)."
    }
    
    disp:drawHLine = {
        description = "See [u8glib drawHLine()](https://github.com/olikraus/u8glib/wiki/userreference#drawhline)."
    }
    
    disp:drawLine = {
        description = "See [u8glib drawLine()](https://github.com/olikraus/u8glib/wiki/userreference#drawline)."
    }
    
    disp:drawPixel = {
        description = "See [u8glib drawPixel()](https://github.com/olikraus/u8glib/wiki/userreference#drawpixel)."
    }
    
    disp:drawRBox = {
        description = "See [u8glib drawRBox()](https://github.com/olikraus/u8glib/wiki/userreference#drawrbox)."
    }
    
    disp:drawRFrame = {
        description = "See [u8glib drawRFrame()](https://github.com/olikraus/u8glib/wiki/userreference#drawrframe)."
    }
    
    disp:drawStr = {
        description = "See [u8glib drawStr()](https://github.com/olikraus/u8glib/wiki/userreference#drawstr)."
    }
    
    disp:drawStr90 = {
        description = "See [u8glib drawStr90](https://github.com/olikraus/u8glib/wiki/userreference#drawstr90)."
    }
    
    disp:drawStr180 = {
        description = "See [u8glib drawStr180()](https://github.com/olikraus/u8glib/wiki/userreference#drawstr180)."
    }
    
    disp:drawStr270 = {
        description = "See [u8glib drawStr270()](https://github.com/olikraus/u8glib/wiki/userreference#drawstr270)."
    }
    
    disp:drawTriangle = {
        description = "See [u8glib drawTriangle()](https://github.com/olikraus/u8glib/wiki/userreference#drawtriangle)."
    }
    
    disp:drawVLine = {
        description = "See [u8glib drawVLine()](https://github.com/olikraus/u8glib/wiki/userreference#drawvline)."
    }
    
    disp:drawXBM = {
        description = "Draw a XBM Bitmap. Position (x,y) is the upper left corner of the bitmap. , XBM contains monochrome, 1-bit bitmaps. This procedure only draws pixel values 1. The current color index is used for drawing (see setColorIndex). Pixel with value 0 are not drawn (transparent). , Bitmaps and XBMs are supplied as strings to drawBitmap() and drawXBM(). This off-loads all data handling from the u8g module to generic methods for binary files. In contrast to the source code based inclusion of XBMs into u8glib, it's required to provide precompiled binary files. This can be performed online with [Online-Utility's Image Converter](http://www.online-utility.org/image_converter.jsp): Convert from XBM to MONO format and upload the binary result with [nodemcu-uploader.py](https://github.com/kmpm/nodemcu-uploader) or [ESPlorer](http://esp8266.ru/esplorer/)."
        syntax = "disp:drawXBM(x, y, w, h, bitmap)"
        parameters = "- x X-position (left position of the bitmap) , - y Y-position (upper position of the bitmap) , - w width of the bitmap , - h height of the bitmap , - bitmap XBM data supplied as string"
        returns = "nil"
        seealso = "- [u8glib drawXBM()](https://github.com/olikraus/u8glib/wiki/userreference#drawxbm) , - [lua_examples/u8glib/u8g_bitmaps.lua](https://github.com/nodemcu/nodemcu-firmware/blob/master/lua_examples/u8glib/u8g_bitmaps.lua) , - [u8g.disp:drawBitmap()](#u8gdispdrawbitmap)"
    }
    
    disp:firstPage = {
        description = "See [u8glib firstPage()](https://github.com/olikraus/u8glib/wiki/userreference#firstpage)."
    }
    
    disp:getColorIndex = {
        description = "See [u8glib getColorIndex()](https://github.com/olikraus/u8glib/wiki/userreference#getcolorindex)."
    }
    
    disp:getFontAscent = {
        description = "See [u8glib getFontAscent()](https://github.com/olikraus/u8glib/wiki/userreference#getfontascent)."
    }
    
    disp:getFontDescent = {
        description = "See [u8glib getFontDescent()](https://github.com/olikraus/u8glib/wiki/userreference#getfontdescent)."
    }
    
    disp:getFontLineSpacing = {
        description = "See [u8glib getFontLineSpacing()](https://github.com/olikraus/u8glib/wiki/userreference#getfontlinespacing)."
    }
    
    disp:getHeight = {
        description = "See [u8glib getHeight()](https://github.com/olikraus/u8glib/wiki/userreference#getheight)."
    }
    
    disp:getMode = {
        description = "See [u8glib getMode()](https://github.com/olikraus/u8glib/wiki/userreference#getmode)."
    }
    
    disp:getWidth = {
        description = "See [u8glib getWidth()](https://github.com/olikraus/u8glib/wiki/userreference#getwidth)."
    }
    
    disp:getStrWidth = {
        description = "See [u8glib getStrWidth](https://github.com/olikraus/u8glib/wiki/userreference#getstrwidth)."
    }
    
    disp:nextPage = {
        description = "See [u8glib nextPage()](https://github.com/olikraus/u8glib/wiki/userreference#nextpage)."
    }
    
    disp:setColorIndex = {
        description = "See [u8glib setColorIndex()](https://github.com/olikraus/u8glib/wiki/userreference#setcolortndex)."
    }
    
    disp:setDefaultBackgroundColor = {
        description = "See [u8glib setDefaultBackgroundColor()](https://github.com/olikraus/u8glib/wiki/userreference#setdefaultbackgroundcolor)."
    }
    
    disp:setDefaultForegroundColor = {
        description = "See [u8glib setDefaultForegroundColor()](https://github.com/olikraus/u8glib/wiki/userreference#setdefaultforegroundcolor)."
    }
    
    disp:setFont = {
        description = "u8glib comes with a wide range of fonts for small displays. , Since they need to be compiled into the firmware image, you'd need to include them in app/include/u8g_config.h and recompile. Simply add the desired fonts to the font table: , c , #define U8G_FONT_TABLE \ ,     U8G_FONT_TABLE_ENTRY(font_6x10)  \ ,     U8G_FONT_TABLE_ENTRY(font_chikita) ,  , They'll be available as u8g.<font_name> in Lua."
        syntax = "disp:setFont(font)"
        parameters = "font Constant to indentify pre-compiled font"
        returns = "nil"
        example = "lua , disp:setFont(u8g.font_6x10) , "
        seealso = "- [u8glib setFont()](https://github.com/olikraus/u8glib/wiki/userreference#setfont)"
    }
    
    disp:setFontLineSpacingFactor = {
        description = "See [u8glib setFontLineSpacingFactor()](https://github.com/olikraus/u8glib/wiki/userreference#setfontlinespacingfactor)."
    }
    
    disp:setFontPosBaseline = {
        description = "See [u8glib setFontPosBaseline()](https://github.com/olikraus/u8glib/wiki/userreference#setfontposbaseline)."
    }
    
    disp:setFontPosBottom = {
        description = "See [u8glib setFontPosBottom()](https://github.com/olikraus/u8glib/wiki/userreference#setfontposbottom)."
    }
    
    disp:setFontPosCenter = {
        description = "See [u8glib setFontPosCenter()](https://github.com/olikraus/u8glib/wiki/userreference#setfontposcenter)."
    }
    
    disp:setFontPosTop = {
        description = "See [u8glib setFontPosTop()](https://github.com/olikraus/u8glib/wiki/userreference#setfontpostop)."
    }
    
    disp:setFontRefHeightAll = {
        description = "See [u8glib setFontRefHeightAll()](https://github.com/olikraus/u8glib/wiki/userreference#setfontrefheightall)."
    }
    
    disp:setFontRefHeightExtendedText = {
        description = "See [u8glib setFontRefHeightExtendedText()](https://github.com/olikraus/u8glib/wiki/userreference#setfontrefheightextendedtext)."
    }
    
    disp:setFontRefHeightText = {
        description = "See [u8glib setFontRefHeightText()](https://github.com/olikraus/u8glib/wiki/userreference#setfontrefheighttext)."
    }
    
    disp:setRot90 = {
        description = "See [u8glib setRot90()](https://github.com/olikraus/u8glib/wiki/userreference#setrot90)."
    }
    
    disp:setRot180 = {
        description = "See [u8glib setRot180()](https://github.com/olikraus/u8glib/wiki/userreference#setrot180)."
    }
    
    disp:setRot270 = {
        description = "See [u8glib setRot270()](https://github.com/olikraus/u8glib/wiki/userreference#setrot270)."
    }
    
    disp:setScale2x2 = {
        description = "See [u8glib setScale2x2()](https://github.com/olikraus/u8glib/wiki/userreference#setscale2x2)."
    }
    
    disp:sleepOn = {
        description = "See [u8glib sleepOn()](https://github.com/olikraus/u8glib/wiki/userreference#sleepon)."
    }
    
    disp:sleepOff = {
        description = "See [u8glib sleepOff()](https://github.com/olikraus/u8glib/wiki/userreference#sleepoff)."
    }
    
    disp:undoRotation = {
        description = "See [u8glib undoRotation()](https://github.com/olikraus/u8glib/wiki/userreference#undorotation)."
    }
    
    disp:undoScale = {
        description = "See [u8glib undoScale()](https://github.com/olikraus/u8glib/wiki/userreference#undoscale)."
    }
    
    Unimplemented = {
        description = "- Cursor handling , 	- disableCursor() , 	- enableCursor() , 	- setCursorColor() , 	- setCursorFont() , 	- setCursorPos() , 	- setCursorStyle() , - General functions , 	- setContrast() , 	- setPrintPos() , 	- setHardwareBackup() , 	- setRGB() , 	- setDefaultMidColor()"
    }

}
uart = {
    
    alt = {
        description = "Change UART pin assignment."
        syntax = "uart.alt(on)"
        parameters = "on , - 0 for standard pins , - 1 to use alternate pins GPIO13 and GPIO15"
        returns = "nil"
    }
    
    on = {
        description = "Sets the callback function to handle UART events. , Currently only the "data" event is supported."
        syntax = "uart.on(method, [number/end_char], [function], [run_input])"
        parameters = "- method "data", data has been received on the UART , - number/end_char , 	- if pass in a number n<255, the callback will called when n chars are received. , 	- if n=0, will receive every char in buffer. , 	- if pass in a one char string "c", the callback will called when "c" is encounterd, or max n=255 received. , - function callback function, event "data" has a callback like this: function(data) end , - run_input 0 or 1. If 0, input from UART will not go into Lua interpreter, can accept binary data. If 1, input from UART will go into Lua interpreter, and run. , To unregister the callback, provide only the "data" parameter."
        returns = "nil"
        example = "lua , -- when 4 chars is received. , uart.on("data", 4, ,   function(data) , 	print("receive from uart:", data) , 	if data=="quit" then , 	  uart.on("data") -- unregister callback function , 	end , end, 0) , -- when '\r' is received. , uart.on("data", "\r", ,   function(data) , 	print("receive from uart:", data) , 	if data=="quit\r" then , 	  uart.on("data") -- unregister callback function , 	end , end, 0)"
    }
    
    setup = {
        description = "(Re-)configures the communication parameters of the UART."
        syntax = "uart.setup(id, baud, databits, parity, stopbits, echo)"
        parameters = "- id always zero, only one uart supported , - baud one of 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 74880, 115200, 230400, 256000, 460800, 921600, 1843200, 3686400 , - databits one of 5, 6, 7, 8 , - parity uart.PARITY_NONE, uart.PARITY_ODD, or uart.PARITY_EVEN , - stopbits uart.STOPBITS_1, uart.STOPBITS_1_5, or uart.STOPBITS_2 , - echo if 0, disable echo, otherwise enable echo"
        returns = "configured baud rate (number)"
        example = "lua , -- configure for 9600, 8N1, with echo , uart.setup(0, 9600, 8, uart.PARITY_NONE, uart.STOPBITS_1, 1)"
    }
    
    write = {
        description = "Write string or byte to the UART."
        syntax = "uart.write(id, data1 [, data2, ...])"
        parameters = "- id always 0, only one UART supported , - data1... string or byte to send via UART"
        returns = "nil"
        example = "lua , uart.write(0, "Hello, world\n") , "
    }

}
ucg = {
    ili9163_18x128x128_hw_spi = {
        description = "Initialize a display via Hardware SPI."
        syntax = "ucg.ili9163_18x128x128_hw_spi(cs, dc[, res])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES (optional)"
        returns = "ucg display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8, 0) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = ucg.st7735_18x128x160_hw_spi(cs, dc, res) ,  , ####Constants , Constants for various functions. , ucg.FONT_MODE_TRANSPARENT, ucg.FONT_MODE_SOLID, ucg.DRAW_UPPER_RIGHT, , ucg.DRAW_UPPER_LEFT, ucg.DRAW_LOWER_RIGHT, ucg.DRAW_LOWER_LEFT, ucg.DRAW_ALL , ucg.font_7x13B_tr, ... , ####ucg.disp Sub-Module"    
    }
    
    ili9341_18x240x320_hw_spi = {
        description = "Initialize a display via Hardware SPI."
        syntax = "ucg.ili9341_18x240x320_hw_spi(cs, dc[, res])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES (optional)"
        returns = "ucg display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8, 0) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = ucg.st7735_18x128x160_hw_spi(cs, dc, res) ,  , ####Constants , Constants for various functions. , ucg.FONT_MODE_TRANSPARENT, ucg.FONT_MODE_SOLID, ucg.DRAW_UPPER_RIGHT, , ucg.DRAW_UPPER_LEFT, ucg.DRAW_LOWER_RIGHT, ucg.DRAW_LOWER_LEFT, ucg.DRAW_ALL , ucg.font_7x13B_tr, ... , ####ucg.disp Sub-Module"    
    }

    pcf8833_16x132x132_hw_spi = {
        description = "Initialize a display via Hardware SPI."
        syntax = "ucg.pcf8833_16x132x132_hw_spi(cs, dc[, res])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES (optional)"
        returns = "ucg display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8, 0) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = ucg.st7735_18x128x160_hw_spi(cs, dc, res) ,  , ####Constants , Constants for various functions. , ucg.FONT_MODE_TRANSPARENT, ucg.FONT_MODE_SOLID, ucg.DRAW_UPPER_RIGHT, , ucg.DRAW_UPPER_LEFT, ucg.DRAW_LOWER_RIGHT, ucg.DRAW_LOWER_LEFT, ucg.DRAW_ALL , ucg.font_7x13B_tr, ... , ####ucg.disp Sub-Module"    
    }

    seps225_16x128x128_uvis_hw_spi = {
        description = "Initialize a display via Hardware SPI."
        syntax = "ucg.seps225_16x128x128_uvis_hw_spi(cs, dc[, res])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES (optional)"
        returns = "ucg display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8, 0) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = ucg.st7735_18x128x160_hw_spi(cs, dc, res) ,  , ####Constants , Constants for various functions. , ucg.FONT_MODE_TRANSPARENT, ucg.FONT_MODE_SOLID, ucg.DRAW_UPPER_RIGHT, , ucg.DRAW_UPPER_LEFT, ucg.DRAW_LOWER_RIGHT, ucg.DRAW_LOWER_LEFT, ucg.DRAW_ALL , ucg.font_7x13B_tr, ... , ####ucg.disp Sub-Module"    
    }

    ssd1351_18x128x128_hw_spi = {
        description = "Initialize a display via Hardware SPI."
        syntax = "ucg.ssd1351_18x128x128_hw_spi(cs, dc[, res])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES (optional)"
        returns = "ucg display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8, 0) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = ucg.st7735_18x128x160_hw_spi(cs, dc, res) ,  , ####Constants , Constants for various functions. , ucg.FONT_MODE_TRANSPARENT, ucg.FONT_MODE_SOLID, ucg.DRAW_UPPER_RIGHT, , ucg.DRAW_UPPER_LEFT, ucg.DRAW_LOWER_RIGHT, ucg.DRAW_LOWER_LEFT, ucg.DRAW_ALL , ucg.font_7x13B_tr, ... , ####ucg.disp Sub-Module"    
    }

    ssd1351_18x128x128_ft_hw_spi = {
        description = "Initialize a display via Hardware SPI."
        syntax = "ucg.ssd1351_18x128x128_ft_hw_spi(cs, dc[, res])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES (optional)"
        returns = "ucg display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8, 0) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = ucg.st7735_18x128x160_hw_spi(cs, dc, res) ,  , ####Constants , Constants for various functions. , ucg.FONT_MODE_TRANSPARENT, ucg.FONT_MODE_SOLID, ucg.DRAW_UPPER_RIGHT, , ucg.DRAW_UPPER_LEFT, ucg.DRAW_LOWER_RIGHT, ucg.DRAW_LOWER_LEFT, ucg.DRAW_ALL , ucg.font_7x13B_tr, ... , ####ucg.disp Sub-Module"    
    }

    ssd1331_18x96x64_uvis_hw_spi = {
        description = "Initialize a display via Hardware SPI."
        syntax = "ucg.ssd1331_18x96x64_uvis_hw_spi(cs, dc[, res])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES (optional)"
        returns = "ucg display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8, 0) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = ucg.st7735_18x128x160_hw_spi(cs, dc, res) ,  , ####Constants , Constants for various functions. , ucg.FONT_MODE_TRANSPARENT, ucg.FONT_MODE_SOLID, ucg.DRAW_UPPER_RIGHT, , ucg.DRAW_UPPER_LEFT, ucg.DRAW_LOWER_RIGHT, ucg.DRAW_LOWER_LEFT, ucg.DRAW_ALL , ucg.font_7x13B_tr, ... , ####ucg.disp Sub-Module"    
    }

    st7735_18x128x160_hw_spi = {
        description = "Initialize a display via Hardware SPI."
        syntax = "ucg.st7735_18x128x160_hw_spi(cs, dc[, res])"
        parameters = "- cs GPIO pin for /CS , - dc GPIO pin for DC , - res GPIO pin for /RES (optional)"
        returns = "ucg display object"
        example = "lua , spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8, 0) , cs  = 8 -- GPIO15, pull-down 10k to GND , dc  = 4 -- GPIO2 , res = 0 -- GPIO16, RES is optional YMMV , disp = ucg.st7735_18x128x160_hw_spi(cs, dc, res) ,  , ####Constants , Constants for various functions. , ucg.FONT_MODE_TRANSPARENT, ucg.FONT_MODE_SOLID, ucg.DRAW_UPPER_RIGHT, , ucg.DRAW_UPPER_LEFT, ucg.DRAW_LOWER_RIGHT, ucg.DRAW_LOWER_LEFT, ucg.DRAW_ALL , ucg.font_7x13B_tr, ... , ####ucg.disp Sub-Module"    
    }
    
    disp:begin = {
        description = "See [ucglib begin()](https://github.com/olikraus/ucglib/wiki/reference#begin)."
    }
    
    disp:clearScreen = {
        description = "See [ucglib clearScreen()](https://github.com/olikraus/ucglib/wiki/reference#clearscreen)."
    }
    
    disp:draw90Line = {
        description = "See [ucglib draw90Line()](https://github.com/olikraus/ucglib/wiki/reference#draw90line)."
    }
    
    disp:drawBox = {
        description = "See [ucglib drawBox()](https://github.com/olikraus/ucglib/wiki/reference#drawbox)."
    }
    
    disp:drawCircle = {
        description = "See [ucglib drawCircle()](https://github.com/olikraus/ucglib/wiki/reference#drawcircle)."
    }
    
    disp:drawDisc = {
        description = "See [ucglib drawDisc()](https://github.com/olikraus/ucglib/wiki/reference#drawdisc)."
    }
    
    disp:drawFrame = {
        description = "See [ucglib drawFrame()](https://github.com/olikraus/ucglib/wiki/reference#drawframe)."
    }
    
    disp:drawGlyph = {
        description = "See [ucglib drawGlyph()](https://github.com/olikraus/ucglib/wiki/reference#drawglyph)."
    }
    
    disp:drawGradientBox = {
        description = "See [ucglib drawGradientBox()](https://github.com/olikraus/ucglib/wiki/reference#drawgradientbox)."
    }
    
    disp:drawGradientLine = {
        description = "See [ucglib drawGradientLine()](https://github.com/olikraus/ucglib/wiki/reference#drawgradientline)."
    }
    
    disp:drawHLine = {
        description = "See [ucglib drawHLine()](https://github.com/olikraus/ucglib/wiki/reference#drawhline)."
    }
    
    disp:drawLine = {
        description = "See [ucglib drawLine()](https://github.com/olikraus/ucglib/wiki/reference#drawline)."
    }
    
    disp:drawPixel = {
        description = "See [ucglib drawPixel()](https://github.com/olikraus/ucglib/wiki/reference#drawpixel)."
    }
    
    disp:drawRBox = {
        description = "See [ucglib drawRBox()](https://github.com/olikraus/ucglib/wiki/reference#drawrbox)."
    }
    
    disp:drawRFrame = {
        description = "See [ucglib drawRFrame()](https://github.com/olikraus/ucglib/wiki/reference#drawrframe)."
    }
    
    disp:drawString = {
        description = "See [ucglib drawString()](https://github.com/olikraus/ucglib/wiki/reference#drawstring)."
    }
    
    disp:drawTetragon = {
        description = "See [ucglib drawTetragon()](https://github.com/olikraus/ucglib/wiki/reference#drawtetragon)."
    }
    
    disp:drawTriangle = {
        description = "See [ucglib drawTriangle()](https://github.com/olikraus/ucglib/wiki/reference#drawrtiangle)."
    }
    
    disp:drawVLine = {
        description = "See [ucglib drawVline()](https://github.com/olikraus/ucglib/wiki/reference#drawvline)."
    }
    
    disp:getFontAscent = {
        description = "See [ucglib getFontAscent()](https://github.com/olikraus/ucglib/wiki/reference#getfontascent)."
    }
    
    disp:getFontDescent = {
        description = "See [ucglib getFontDescent()](https://github.com/olikraus/ucglib/wiki/reference#getfontdescent)."
    }
    
    disp:getHeight = {
        description = "See [ucglib getHeight()](https://github.com/olikraus/ucglib/wiki/reference#getheight)."
    }
    
    disp:getStrWidth = {
        description = "See [ucglib getStrWidth()](https://github.com/olikraus/ucglib/wiki/reference#getstrwidth)."
    }
    
    disp:getWidth = {
        description = "See [ucglib getWidth()](https://github.com/olikraus/ucglib/wiki/reference#getwidth)."
    }
    
    disp:print = {
        description = "See [ucglib print()](https://github.com/olikraus/ucglib/wiki/reference#print)."
    }
    
    disp:setClipRange = {
        description = "See [ucglib setClipRange()](https://github.com/olikraus/ucglib/wiki/reference#setcliprange)."
    }
    
    disp:setColor = {
        description = "See [ucglib setColor()](https://github.com/olikraus/ucglib/wiki/reference#setcolor)."
    }
    
    disp:setFont = {
        description = "ucglib comes with a wide range of fonts for small displays. Since they need to be compiled into the firmware image, you'd need to include them in [app/include/ucg_config.h](https://github.com/nodemcu/nodemcu-firmware/blob/master/app/include/ucg_config.h) and recompile. Simply add the desired fonts to the font table: , c , #define UCG_FONT_TABLE                              \ ,     UCG_FONT_TABLE_ENTRY(font_7x13B_tr)             \ ,     UCG_FONT_TABLE_ENTRY(font_helvB12_hr)           \ ,     UCG_FONT_TABLE_ENTRY(font_helvB18_hr)           \ ,     UCG_FONT_TABLE_ENTRY(font_ncenR12_tr)           \ ,     UCG_FONT_TABLE_ENTRY(font_ncenR14_hr) ,  , They'll be available as ucg.<font_name> in Lua."
        syntax = "disp:setFont(font)"
        parameters = "font constant to identify pre-compiled font"
        returns = "nil"
        example = "lua , disp:setFont(ucg.font_7x13B_tr) , "
        seealso = "[ucglib setFont()](https://github.com/olikraus/ucglib/wiki/reference#setfont)"
    }
    
    disp:setFontMode = {
        description = "See [ucglib setFontMode()](https://github.com/olikraus/ucglib/wiki/reference#setfontmode)."
    }
    
    disp:setFontPosBaseline = {
        description = "See [ucglib setFontPosBaseline()](https://github.com/olikraus/ucglib/wiki/reference#setfontposbaseline)."
    }
    
    disp:setFontPosBottom = {
        description = "See [ucglib setFontPosBottom()](https://github.com/olikraus/ucglib/wiki/reference#setfontposbottom)."
    }
    
    disp:setFontPosCenter = {
        description = "See [ucglib setFontPosCenter()](https://github.com/olikraus/ucglib/wiki/reference#setfontposcenter)."
    }
    
    disp:setFontPosTop = {
        description = "See [ucglib setFontPosTop()](https://github.com/olikraus/ucglib/wiki/reference#setfontpostop)."
    }
    
    disp:setMaxClipRange = {
        description = "See [ucglib setMaxClipRange()](https://github.com/olikraus/ucglib/wiki/reference#setmaxcliprange)."
    }
    
    disp:setPrintDir = {
        description = "See [ucglib setPrintDir()](https://github.com/olikraus/ucglib/wiki/reference#setprintdir)."
    }
    
    disp:setPrintPos = {
        description = "See [ucglib setPrintPos()](https://github.com/olikraus/ucglib/wiki/reference#setprintpos)."
    }
    
    disp:setRotate90 = {
        description = "See [ucglib setRotate90()](https://github.com/olikraus/ucglib/wiki/reference#setrotate90)."
    }
    
    disp:setRotate180 = {
        description = "See [ucglib setRotate180()](https://github.com/olikraus/ucglib/wiki/reference#setrotate180)."
    }
    
    disp:setRotate270 = {
        description = "See [ucglib setRotate270()](https://github.com/olikraus/ucglib/wiki/reference#setrotate270)."
    }
    
    disp:setScale2x2 = {
        description = "See [ucglib setScale2x2()](https://github.com/olikraus/ucglib/wiki/reference#setscale2x2)."
    }
    
    disp:undoClipRange = {
        description = "See [ucglib undoClipRange()](https://github.com/olikraus/ucglib/wiki/reference#undocliprange)."
    }
    
    disp:undoRotate = {
        description = "See [ucglib undoRotate()](https://github.com/olikraus/ucglib/wiki/reference#undorotate)."
    }
    
    disp:undoScale = {
        description = "See [ucglib undoScale()](https://github.com/olikraus/ucglib/wiki/reference#undoscale)."
    }

}
wifi = {
    
    getchannel = {
        description = "Gets the current WiFi channel."
        syntax = "wifi.getchannel()"
        parameters = "nil"
        returns = "current WiFi channel"
    }
    
    getmode = {
        description = "Gets WiFi operation mode."
        syntax = "wifi.getmode()"
        parameters = "nil"
        returns = "The WiFi mode, as one of the wifi.STATION, wifi.SOFTAP, wifi.STATIONAP or wifi.NULLMODE constants."
        seealso = "[wifi.setmode()](#wifisetmode)"
    }
    
    getphymode = {
        description = "Gets WiFi physical mode."
        syntax = "wifi.getpymode()"
        parameters = "none"
        returns = "The current physical mode as one of wifi.PHYMODE_B, wifi.PHYMODE_G or wifi.PHYMODE_N."
        seealso = "[wifi.setphymode()](#wifisetphymode)"
    }
    
    setmode = {
        description = "Configures the WiFi mode to use. NodeMCU can run in one of four WiFi modes: , - Station mode, where the NodeMCU device joins an existing network , - Access point (AP) mode, where it creates its own network that others can join , - Station + AP mode, where it both creates its own network while at the same time being joined to another existing network , - WiFi off , When using the combined Station + AP mode, the same channel will be used for both networks as the radio can only listen on a single channel. , NOTE: WiFi Mode configuration will be retained until changed even if device is turned off. "
        syntax = "wifi.setmode(mode)"
        parameters = "mode value should be one of , - wifi.STATION for when the device is connected to a WiFi router. This is often done to give the device access to the Internet. , - wifi.SOFTAP for when the device is acting *only* as an access point. This will allow you to see the device in the list of WiFi networks (unless you hide the SSID, of course). In this mode your computer can connect to the device, creating a local area network. Unless you change the value, the NodeMCU device will be given a local IP address of 192.168.4.1 and assign your computer the next available IP address, such as 192.168.4.2. , - wifi.STATIONAP is the combination of wifi.STATION and wifi.SOFTAP. It allows you to create a local WiFi connection *and* connect to another WiFi router. , - wifi.NULLMODE to switch off WiFi"
        returns = "current mode after setup"
        example = "lua , wifi.setmode(wifi.STATION) , "
        seealso = "[wifi.getmode()](#wifigetmode)"
    }
    
    setphymode = {
        description = "Sets WiFi physical mode. ,   , - wifi.PHYMODE_B ,     802.11b, more range, low Transfer rate, more current draw , - wifi.PHYMODE_G ,     802.11g, medium range, medium transfer rate, medium current draw , - wifi.PHYMODE_N ,     802.11n, least range, fast transfer rate, least current draw (STATION ONLY) , Information from the Espressif datasheet v4.3 , |           Parameters                        |Typical Power Usage| , |---------------------------------------------|-------------------| , |Tx 802.11b, CCK 11Mbps, P OUT=+17dBm         |     170 mA        | , |Tx 802.11g, OFDM 54Mbps, P OUT =+15dBm       |     140 mA        | , |Tx 802.11n, MCS7 65Mbps, P OUT =+13dBm       |     120 mA        | , |Rx 802.11b, 1024 bytes packet length, -80dBm |      50 mA        | , |Rx 802.11g, 1024 bytes packet length, -70dBm |      56 mA        | , |Rx 802.11n, 1024 bytes packet length, -65dBm |      56 mA        |"
        syntax = "wifi.setphymode(mode)"
        parameters = "mode one of the following  , - wifi.PHYMODE_B , - wifi.PHYMODE_G , - wifi.PHYMODE_N"
        returns = "physical mode after setup"
        seealso = "[wifi.getphymode()](#wifigetphymode)"
    }
    
    sleeptype = {
        description = "Configures the WiFi modem sleep type."
        syntax = "wifi.sleeptype(type_wanted)"
        parameters = "type_wanted one of the following: , - wifi.NONE_SLEEP to keep the modem on at all times , - wifi.LIGHT_SLEEP to allow the modem to power down under some circumstances , - wifi.MODEM_SLEEP to power down the modem as much as possible"
        returns = "The actual sleep mode set, as one of wifi.NONE_SLEEP, wifi.LIGHT_SLEEP or wifi.MODEM_SLEEP."
        seealso = "- [node.dsleep()](node.md#nodedsleep) , - [rtctime.dsleep()](rtctime.md#rtctimedsleep)"
    }
    
    startsmart = {
        description = "Starts to auto configuration, if success set up SSID and password automatically. , Intended for use with SmartConfig apps, such as Espressif's [Android & iOS app](https://github.com/espressifapp). , Only usable in wifi.STATION mode. , !!! note "Note:" ,     SmartConfig is disabled by default and can be enabled by setting WIFI_SMART_ENABLE in [user_config.h](https://github.com/nodemcu/nodemcu-firmware/blob/dev/app/include/user_config.h#L96) before you build the firmware."
        syntax = "wifi.startsmart(type, callback)"
        parameters = "- type 0 for ESP\_TOUCH, or 1 for AIR\_KISS. , - callback a callback function of the form function(ssid, password) end which gets called after configuration."
        returns = "nil"
        example = "lua , wifi.setmode(wifi.STATION) , wifi.startsmart(0, , 	function(ssid, password) , 		print(string.format("Success. SSID:%s ; PASSWORD:%s", ssid, password)) , 	end , ) , "
        seealso = "[wifi.stopsmart()](#wifistopsmart)"
    }
    
    stopsmart = {
        description = "Stops the smart configuring process."
        syntax = "wifi.stopsmart()"
        parameters = "none"
        returns = "nil"
        seealso = "[wifi.startsmart()](#wifistartsmart) , ####wifi.sta Module"
    }
    
    sta.autoconnect = {
        description = "Auto connects to AP in station mode."
        syntax = "wifi.sta.autoconnect(auto)"
        parameters = "auto 0 to disable auto connecting, 1 to enable auto connecting"
        returns = "nil"
        example = "lua , wifi.sta.autoconnect(1) , "
        seealso = "- [wifi.sta.config()](#wifistaconfig) , - [wifi.sta.connect()](#wifistaconnect) , - [wifi.sta.disconnect()](#wifistadisconnect)"
    }
    
    sta.config = {
        description = "Sets the WiFi station configuration. , NOTE: Station configuration will be retained until changed even if device is turned off. "
        syntax = "wifi.sta.config(ssid, password[, auto[, bssid]])"
        parameters = "- ssid string which is less than 32 bytes. , - password string which is 8-64 or 0 bytes. Empty string indicates an open WiFi access point. , - auto defaults to 1 , 	- 0 to disable auto connect and remain disconnected from access point , 	- 1 to enable auto connect and connect to access point, hence with auto=1 there's no need to call [wifi.sta.connect()](#wifistaconnect) later , - bssid string that contains the MAC address of the access point (optional) , 	- You can set BSSID if you have multiple access points with the same SSID. ,  	- Note: if you set BSSID for a specific SSID and would like to configure station to connect to the same SSID only without the BSSID requirement, you MUST first configure to station to a different SSID first, then connect to the desired SSID ,  	- The following formats are valid: , 		- "DE-C1-A5-51-F1-ED" , 		- "AC-1D-1C-B1-0B-22" , 		- "DE AD BE EF 7A C0""
        returns = "nil"
        example = "lua , -- Connect to access point automatically when in range, auto defaults to 1 , wifi.sta.config("myssid", "password") , -- Connect to Unsecured access point automatically when in range, auto defaults to 1 , wifi.sta.config("myssid", "") ,    , -- Connect to access point, User decides when to connect/disconnect to/from AP due to auto=0 , wifi.sta.config("myssid", "mypassword", 0) , wifi.sta.connect() , -- ... do some WiFi stuff , wifi.sta.disconnect() ,     , -- Connect to specific access point automatically when in range, auto defaults to 1 , wifi.sta.config("myssid", "mypassword", "12:34:56:78:90:12") , -- Connect to specific access point, User decides when to connect/disconnect to/from AP due to auto=0 , wifi.sta.config("myssid", "mypassword", 0, "12:34:56:78:90:12") , wifi.sta.connect() , -- ... do some WiFi stuff , wifi.sta.disconnect() , "
        seealso = "- [wifi.sta.connect()](#wifistaconnect) , - [wifi.sta.disconnect()](#wifistadisconnect)"
    }
    
    sta.connect = {
        description = "Connects to the configured AP in station mode. You only ever need to call this if auto-connect was disabled in [wifi.sta.config()](#wifistaconfig)."
        syntax = "wifi.sta.connect()"
        parameters = "none"
        returns = "nil"
        seealso = "- [wifi.sta.disconnect()](#wifistadisconnect) , - [wifi.sta.config()](#wifistaconfig)"
    }
    
    sta.disconnect = {
        description = "Disconnects from AP in station mode."
        syntax = "wifi.sta.disconnect()"
        parameters = "none"
        returns = "nil"
        seealso = "- [wifi.sta.config()](#wifistaconfig) , - [wifi.sta.connect()](#wifistaconnect)"
    }
    
    sta.eventMonReg = {
        description = "Registers callbacks for WiFi station status events."
        syntax = "- wifi.sta.eventMonReg(wifi_status[, function([previous_state])])"
        parameters = "- wifi_status WiFi status you would like to set a callback for:  ,     - wifi.STA_IDLE ,     - wifi.STA_CONNECTING ,     - wifi.STA_WRONGPWD ,     - wifi.STA_APNOTFOUND ,     - wifi.STA_FAIL ,     - wifi.STA_GOTIP , - function callback function to perform when event occurs  , 	- Note: leaving field blank unregisters callback. , - previous_state previous wifi_state(0 - 5)"
        returns = "nil"
        example = "lua  , --register callback , wifi.sta.eventMonReg(wifi.STA_IDLE, function() print("STATION_IDLE") end) , wifi.sta.eventMonReg(wifi.STA_CONNECTING, function() print("STATION_CONNECTING") end) , wifi.sta.eventMonReg(wifi.STA_WRONGPWD, function() print("STATION_WRONG_PASSWORD") end) , wifi.sta.eventMonReg(wifi.STA_APNOTFOUND, function() print("STATION_NO_AP_FOUND") end) , wifi.sta.eventMonReg(wifi.STA_FAIL, function() print("STATION_CONNECT_FAIL") end) , wifi.sta.eventMonReg(wifi.STA_GOTIP, function() print("STATION_GOT_IP") end) ,    , --register callback: use previous state , wifi.sta.eventMonReg(wifi.STA_CONNECTING, function(previous_State) , 	if(previous_State==wifi.STA_GOTIP) then  , 		print("Station lost connection with access point\n\tAttempting to reconnect...") , 	else , 		print("STATION_CONNECTING") , 	end , end) ,    , --unregister callback , wifi.sta.eventMonReg(wifi.STA_IDLE) , "
        seealso = "- [wifi.sta.eventMonStart()](#wifistaeventmonstart) , - [wifi.sta.eventMonStop()](#wifistaeventmonstop) , - [wifi.eventmon.register()](#wifieventmonregister) , - [wifi.eventmon.unregister()](#wifieventmonunregister)"
    }
    
    sta.eventMonStart = {
        description = "Starts WiFi station event monitor."
        syntax = "wifi.sta.eventMonStart([ms])"
        parameters = "- ms interval between checks in milliseconds, defaults to 150ms if not provided."
        returns = "nil"
        example = "lua , --start WiFi event monitor with default interval , wifi.sta.eventMonStart() , --start WiFi event monitor with 100ms interval , wifi.sta.eventMonStart(100) , "
        seealso = "- [wifi.sta.eventMonReg()](#wifistaeventmonreg) , - [wifi.sta.eventMonStop()](#wifistaeventmonstop) , - [wifi.eventmon.register()](#wifieventmonregister) , - [wifi.eventmon.unregister()](#wifieventmonunregister)"
    }
    
    sta.eventMonStop = {
        description = "Stops WiFi station event monitor."
        syntax = "wifi.sta.eventMonStop([unregister_all])"
        parameters = "- unregister_all enter 1 to unregister all previously registered functions. , 	- Note: leave blank to leave callbacks registered"
        returns = "nil"
        example = "lua , --stop WiFi event monitor , wifi.sta.eventMonStop() , --stop WiFi event monitor and unregister all callbacks , wifi.sta.eventMonStop(1) , "
        seealso = "- [wifi.sta.eventMonReg()](#wifistaeventmonreg) , - [wifi.sta.eventMonStart()](#wifistaeventmonstart) , - [wifi.eventmon.register()](#wifieventmonregister) , - [wifi.eventmon.unregister()](#wifieventmonunregister)"
    }
    
    sta.getap = {
        description = "Scans AP list as a Lua table into callback function."
        syntax = "wifi.sta.getap([[cfg], format,] callback(table))"
        parameters = "- cfg table that contains scan configuration , 	- ssid SSID == nil, don't filter SSID  , 	- bssid BSSID == nil, don't filter BSSID , 	- channel channel == 0, scan all channels, otherwise scan set channel (default is 0) , 	- show_hidden show_hidden == 1, get info for router with hidden SSID (default is 0) , - format select output table format, defaults to 0 , 	- 0: old format (SSID : Authmode, RSSI, BSSID, Channel), any duplicate SSIDs will be discarded , 	- 1: new format (BSSID : SSID, RSSI, auth mode, Channel) , - callback(table) a callback function to receive the AP table when the scan is done. This function receives a table, the key is the BSSID, the value is other info in format: SSID, RSSID, auth mode, channel."
        returns = "nil"
        example = "lua , -- print AP list in old format (format not defined) , function listap(t) , 	for k,v in pairs(t) do , 		print(k.." : "..v) , 	end , end , wifi.sta.getap(listap) , -- Print AP list that is easier to read , function listap(t) -- (SSID : Authmode, RSSI, BSSID, Channel) , 	print("\n"..string.format("%32s","SSID").."\tBSSID\t\t\t\t  RSSI\t\tAUTHMODE\tCHANNEL") , 	for ssid,v in pairs(t) do , 		local authmode, rssi, bssid, channel = string.match(v, "([^,]+),([^,]+),([^,]+),([^,]+)") , 		print(string.format("%32s",ssid).."\t"..bssid.."\t  "..rssi.."\t\t"..authmode.."\t\t\t"..channel) , 	end , end , wifi.sta.getap(listap) , 	 , -- print AP list in new format , function listap(t) , 	for k,v in pairs(t) do , 		print(k.." : "..v) , 	end , end , wifi.sta.getap(1, listap) , -- Print AP list that is easier to read , function listap(t) -- (SSID : Authmode, RSSI, BSSID, Channel) ,  	print("\n\t\t\tSSID\t\t\t\t\tBSSID\t\t\t  RSSI\t\tAUTHMODE\t\tCHANNEL") ,   	for bssid,v in pairs(t) do ,    		local ssid, rssi, authmode, channel = string.match(v, "([^,]+),([^,]+),([^,]+),([^,]*)") ,     	print(string.format("%32s",ssid).."\t"..bssid.."\t  "..rssi.."\t\t"..authmode.."\t\t\t"..channel) , 	end , end , wifi.sta.getap(1, listap) , --check for specific AP , function listap(t) ,  	print("\n\t\t\tSSID\t\t\t\t\tBSSID\t\t\t  RSSI\t\tAUTHMODE\t\tCHANNEL") , 	for bssid,v in pairs(t) do , 		local ssid, rssi, authmode, channel = string.match(v, "([^,]+),([^,]+),([^,]+),([^,]*)") , 		print(string.format("%32s",ssid).."\t"..bssid.."\t  "..rssi.."\t\t"..authmode.."\t\t\t"..channel) , 	end , end , scan_cfg = {} , scan_cfg.ssid = "myssid"  , scan_cfg.bssid = "AA:AA:AA:AA:AA:AA"  , scan_cfg.channel = 0 , scan_cfg.show_hidden = 1 , wifi.sta.getap(scan_cfg, 1, listap) , --get RSSI for currently configured AP , function listap(t) , 	for bssid,v in pairs(t) do , 		local ssid, rssi, authmode, channel = string.match(v, "([^,]+),([^,]+),([^,]+),([^,]*)") , 		print("CURRENT RSSI IS: "..rssi) , 	end , end , ssid, tmp, bssid_set, bssid=wifi.sta.getconfig()  , scan_cfg = {} , scan_cfg.ssid = ssid  , if bssid_set == 1 then scan_cfg.bssid = bssid else scan_cfg.bssid = nil end , scan_cfg.channel = wifi.getchannel() , scan_cfg.show_hidden = 0 , ssid, tmp, bssid_set, bssid=nil, nil, nil, nil , wifi.sta.getap(scan_cfg, 1, listap) , "
        seealso = "[wifi.sta.getip()](#wifistagetip)"
    }
    
    sta.getbroadcast = {
        description = "Gets the broadcast address in station mode."
        syntax = "wifi.sta.getbroadcast()"
        parameters = "nil"
        returns = "broadcast address as string, for example "192.168.0.255",  , returns nil if IP address = "0.0.0.0"."
        seealso = "[wifi.sta.getip()](#wifistagetip)"
    }
    
    sta.getconfig = {
        description = "Gets the WiFi station configuration. "
        syntax = "wifi.sta.getconfig()"
        parameters = "none"
        returns = "ssid, password, bssid_set, bssid , Note: If bssid_set is equal to 0 then bssid is irrelevant "
        example = "lua , --Get current Station configuration , ssid, password, bssid_set, bssid=wifi.sta.getconfig() , print("\nCurrent Station configuration:\nSSID : "..ssid , .."\nPassword  : "..password , .."\nBSSID_set  : "..bssid_set , .."\nBSSID: "..bssid.."\n") , ssid, password, bssid_set, bssid=nil, nil, nil, nil , "
        seealso = "- [wifi.sta.connect()](#wifistaconnect) , - [wifi.sta.disconnect()](#wifistadisconnect)"
    }
    
    sta.gethostname = {
        description = "Gets current station hostname."
        syntax = "wifi.sta.gethostname()"
        parameters = "none"
        returns = "currently configured hostname"
        example = "lua , print("Current hostname is: \""..wifi.sta.gethostname().."\"")"
    }
    
    sta.getip = {
        description = "Gets IP address, netmask, and gateway address in station mode."
        syntax = "wifi.sta.getip()"
        parameters = "none"
        returns = "IP address, netmask, gateway address as string, for example "192.168.0.111". Returns nil if IP = "0.0.0.0"."
        example = "lua , -- print current IP address, netmask, gateway , print(wifi.sta.getip()) , -- 192.168.0.111  255.255.255.0  192.168.0.1 , ip = wifi.sta.getip() , print(ip) , -- 192.168.0.111 , ip, nm = wifi.sta.getip() , print(nm) , -- 255.255.255.0 , "
        seealso = "[wifi.sta.getmac()](#wifistagetmac)"
    }
    
    sta.getmac = {
        description = "Gets MAC address in station mode."
        syntax = "wifi.sta.getmac()"
        parameters = "none"
        returns = "MAC address as string e.g. "18-33-44-FE-55-BB""
        seealso = "[wifi.sta.getip()](#wifistagetip)"
    }
    
    sta.getrssi = {
        description = "Get RSSI(Received Signal Strength Indicator) of the Access Point which ESP8266 station connected to."
        syntax = "wifi.sta.getrssi()"
        parameters = "none"
        returns = "- If station is connected to an access point, rssi is returned. , - If station is not connected to an access point, nil is returned.  "
        example = "lua , RSSI=wifi.sta.getrssi() , print("RSSI is", RSSI)"
    }
    
    sta.sethostname = {
        description = "Sets station hostname."
        syntax = "wifi.sta.sethostname(hostname)"
        parameters = "hostname must only contain letters, numbers and hyphens('-') and be 32 characters or less with first and last character being alphanumeric"
        returns = "nil"
        example = "lua , if (wifi.sta.sethostname("NodeMCU") == true) then , 	print("hostname was successfully changed") , else , 	print("hostname was not changed") , end"
    }
    
    sta.setip = {
        description = "Sets IP address, netmask, gateway address in station mode."
        syntax = "wifi.sta.setip(cfg)"
        parameters = "cfg table contain IP address, netmask, and gateway , lua , { ,   ip = "192.168.0.111", ,   netmask = "255.255.255.0", ,   gateway = "192.168.0.1" , } , "
        returns = "true if success, false otherwise"
        seealso = "[wifi.sta.setmac()](#wifistasetmac)"
    }
    
    sta.setmac = {
        description = "Sets MAC address in station mode."
        syntax = "wifi.sta.setmac(mac)"
        parameters = "MAC address in string e.g. "DE:AD:BE:EF:7A:C0""
        returns = "true if success, false otherwise"
        example = "lua , print(wifi.sta.setmac("DE:AD:BE:EF:7A:C0")) , "
        seealso = "[wifi.sta.setip()](#wifistasetip)"
    }
    
    sta.status = {
        description = "Gets the current status in station mode."
        syntax = "wifi.sta.status()"
        parameters = "nil"
        returns = "number： 0~5 , - 0: STA_IDLE, , - 1: STA_CONNECTING, , - 2: STA_WRONGPWD, , - 3: STA_APNOTFOUND, , - 4: STA_FAIL, , - 5: STA_GOTIP. , ####wifi.ap Module"
    }
    
    ap.config = {
        description = "Sets SSID and password in AP mode. Be sure to make the password at least 8 characters long! If you don't it will default to *no* password and not set the SSID! It will still work as an access point but use a default SSID like e.g. NODE-9997C3. , NOTE: SoftAP Configuration will be retained until changed even if device is turned off. "
        syntax = "wifi.ap.config(cfg)"
        parameters = "- ssid SSID chars 1-32 , - pwd password chars 8-64 , - auth authentication  one of AUTH\_OPEN, AUTH\_WPA\_PSK, AUTH\_WPA2\_PSK, AUTH\_WPA\_WPA2\_PSK, default = AUTH\_OPEN , - channel channel number 1-14 default = 6 , - hidden 0 = not hidden, 1 = hidden, default 0 , - max maximal number of connections 1-4 default=4 , - beacon beacon interval time in range 100-60000, default = 100"
        returns = "nil"
        example = "lua ,  cfg={} ,  cfg.ssid="myssid" ,  cfg.pwd="mypassword" ,  wifi.ap.config(cfg)"
    }
    
    ap.deauth = {
        description = "Deauths (forcibly removes) a client from the ESP access point by sending a corresponding IEEE802.11 management packet (first) and removing the client from it's data structures (afterwards).  , The IEEE802.11 reason code used is 2 for "Previous authentication no longer valid"(AUTH_EXPIRE)."
        syntax = "wifi.ap.deauth([MAC])"
        parameters = "- MAC address of station to be deauthed. , 	- Note: if this field is left blank, all currently connected stations will get deauthed."
        returns = "Returns true unless called while the ESP is in the STATION opmode"
        example = "lua , allowed_mac_list={"18:fe:34:00:00:00", "18:fe:34:00:00:01"} , wifi.eventmon.register(wifi.eventmon.AP_STACONNECTED, function(T)  ,   print("\n\tAP - STATION CONNECTED".."\n\tMAC: "..T.MAC.."\n\tAID: "..T.AID) ,   if(allowed_mac_list~=nil) then ,     for _, v in pairs(allowed_mac_list) do  ,       if(v == T.MAC) then return end  ,     end ,   end ,   wifi.ap.deauth(T.MAC) ,   print("\tStation DeAuthed!") , end) , "
        seealso = "[wifi.eventmon.register()](#wifieventmonregister)   , [wifi.eventmon.reason()](#wifieventmonreason)"
    }
    
    ap.getbroadcast = {
        description = "Gets broadcast address in AP mode."
        syntax = "wifi.ap.getbroadcast()"
        parameters = "none"
        returns = "broadcast address in string, for example "192.168.0.255",  , returns nil if IP address = "0.0.0.0"."
        example = "lua , bc = wifi.ap.getbroadcast() , print(bc) , -- 192.168.0.255 , "
        seealso = "[wifi.ap.getip()](#wifiapgetip)"
    }
    
    ap.getclient = {
        description = "Gets table of clients connected to device in AP mode."
        syntax = "wifi.ap.getclient()"
        parameters = "none"
        returns = "table of connected clients"
        example = "lua , table={} , table=wifi.ap.getclient() , for mac,ip in pairs(table) do , 	print(mac,ip) , end , -- or shorter , for mac,ip in pairs(wifi.ap.getclient()) do , 	print(mac,ip) , end"
    }
    
    ap.getip = {
        description = "Gets IP address, netmask and gateway in AP mode."
        syntax = "wifi.ap.getip()"
        parameters = "none"
        returns = "IP address, netmask, gateway address as string, for example "192.168.0.111", returns nil if IP address = "0.0.0.0"."
        example = "lua , -- print current ip, netmask, gateway , print(wifi.ap.getip()) , -- 192.168.4.1  255.255.255.0  192.168.4.1 , ip = wifi.ap.getip() , print(ip) , -- 192.168.4.1 , ip, nm = wifi.ap.getip() , print(nm) , -- 255.255.255.0 , ip, nm, gw = wifi.ap.getip() , print(gw) , -- 192.168.4.1 , "
        seealso = "- [wifi.ap.getmac()](#wifiapgetmac)"
    }
    
    ap.getmac = {
        description = "Gets MAC address in AP mode."
        syntax = "wifi.ap.getmac()"
        parameters = "none"
        returns = "MAC address as string, for example "1A-33-44-FE-55-BB""
        seealso = "[wifi.ap.getip()](#wifiapgetip)"
    }
    
    ap.setip = {
        description = "Sets IP address, netmask and gateway address in AP mode."
        syntax = "wifi.ap.setip(cfg)"
        parameters = "cfg table contain IP address, netmask, and gateway"
        returns = "true if successful, false otherwise"
        example = "lua , cfg = , { , 	ip="192.168.1.1", , 	netmask="255.255.255.0", , 	gateway="192.168.1.1" , } , wifi.ap.setip(cfg) , "
        seealso = "[wifi.ap.setmac()](#wifiapsetmac)"
    }
    
    ap.setmac = {
        description = "Sets MAC address in AP mode."
        syntax = "wifi.ap.setmac(mac)"
        parameters = "MAC address in byte string, for example "AC-1D-1C-B1-0B-22""
        returns = "true if success, false otherwise"
        example = "lua , print(wifi.ap.setmac("AC-1D-1C-B1-0B-22")) , "
        seealso = "[wifi.ap.setip()](#wifiapsetip) , ####wifi.ap.dhcp Module"
    }
    
    ap.dhcp.config = {
        description = "Configure the dhcp service. Currently only supports setting the start address of the dhcp address pool."
        syntax = "wifi.ap.dhcp.config(dhcp_config)"
        parameters = "dhcp_config table containing the start-IP of the DHCP address pool, eg. "192.168.1.100""
        returns = "pool_startip, pool_endip"
        example = "lua , dhcp_config ={} , dhcp_config.start = "192.168.1.100" , wifi.ap.dhcp.config(dhcp_config)"
    }
    
    ap.dhcp.start = {
        description = "Starts the DHCP service."
        syntax = "wifi.ap.dhcp.start()"
        parameters = "none"
        returns = "boolean indicating success"
    }
    
    ap.dhcp.stop = {
        description = "Stops the DHCP service."
        syntax = "wifi.ap.dhcp.stop()"
        parameters = "none"
        returns = "boolean indicating success , ####wifi.eventmon Module , Note: The functions wifi.sta.eventMon___() and wifi.eventmon.___() are completely seperate and can be used independently of one another."
    }
    
    eventmon.register = {
        description = "Register/unregister callbacks for WiFi event monitor."
        syntax = "wifi.eventmon.register(Event[, function(T)])"
        parameters = "Event: WiFi event you would like to set a callback for.   , - Valid WiFi events:   ,  	- wifi.eventmon.STA_CONNECTED   , 	- wifi.eventmon.STA_DISCONNECTED   , 	- wifi.eventmon.STA_AUTHMODE_CHANGE   , 	- wifi.eventmon.STA_GOT_IP   , 	- wifi.eventmon.STA_DHCP_TIMEOUT   , 	- wifi.eventmon.AP_STACONNECTED   , 	- wifi.eventmon.AP_STADISCONNECTED   , 	- wifi.eventmon.AP_PROBEREQRECVED  "
        returns = "Function:   , nil , Callback:   , T: Table returned by event.   , - wifi.eventmon.STA_CONNECTED Station is connected to access point.   , 	- SSID: SSID of access point.   , 	- BSSID: BSSID of access point.   , 	- channel: The channel the access point is on.   , - wifi.eventmon.STA_DISCONNECT: Station was disconnected from access point.   , 	- SSID: SSID of access point.   , 	- BSSID: BSSID of access point.   , 	- REASON: See [wifi.eventmon.reason](#wifieventmonreason) below.   , - wifi.eventmon.STA_AUTHMODE_CHANGE: Access point has changed authorization mode.     , 	- old_auth_mode: Old wifi authorization mode.   , 	- new_auth_mode: New wifi authorization mode.   , - wifi.eventmon.STA_GOT_IP: Station got an IP address.   , 	- IP: The IP address assigned to the station.   , 	- netmask: Subnet mask.   , 	- gateway: The IP address of the access point the station is connected to.   , - wifi.eventmon.STA_DHCP_TIMEOUT: Station DHCP request has timed out.   , 	- Blank table is returned.   , - wifi.eventmon.AP_STACONNECTED: A new client has connected to the access point.   , 	- MAC: MAC address of client that has connected.   , 	- AID: SDK provides no details concerning this return value.   , - wifi.eventmon.AP_STADISCONNECTED: A client has disconnected from the access point.   , 	- MAC: MAC address of client that has disconnected.   , 	- AID: SDK provides no details concerning this return value.   , - wifi.eventmon.AP_PROBEREQRECVED: A probe request was received.   , 	- MAC: MAC address of the client that is probing the access point.   , 	- RSSI: Received Signal Strength Indicator of client.  "
        example = "lua ,  wifi.eventmon.register(wifi.eventmon.STA_CONNECTED, function(T)  ,  print("\n\tSTA - CONNECTED".."\n\tSSID: "..T.SSID.."\n\tBSSID: ".. ,  T.BSSID.."\n\tChannel: "..T.channel) ,  end) ,   ,  wifi.eventmon.register(wifi.eventmon.STA_DISCONNECTED, function(T)  ,  print("\n\tSTA - DISCONNECTED".."\n\tSSID: "..T.SSID.."\n\tBSSID: ".. ,  T.BSSID.."\n\treason: "..T.reason) ,  end) ,  wifi.eventmon.register(wifi.eventmon.STA_AUTHMODE_CHANGE, Function(T)  ,  print("\n\tSTA - AUTHMODE CHANGE".."\n\told_auth_mode: ".. ,  T.old_auth_mode.."\n\tnew_auth_mode: "..T.new_auth_mode)  ,  end) ,  wifi.eventmon.register(wifi.eventmon.STA_GOT_IP, function(T)  ,  print("\n\tSTA - GOT IP".."\n\tStation IP: "..T.IP.."\n\tSubnet mask: ".. ,  T.netmask.."\n\tGateway IP: "..T.gateway) ,  end) ,  wifi.eventmon.register(wifi.eventmon.STA_DHCP_TIMEOUT, function()  ,  print("\n\tSTA - DHCP TIMEOUT") ,  end) ,  wifi.eventmon.register(wifi.eventmon.AP_STACONNECTED, function(T)  ,  print("\n\tAP - STATION CONNECTED".."\n\tMAC: "..T.MAC.."\n\tAID: "..T.AID) ,  end) ,  wifi.eventmon.register(wifi.eventmon.AP_STADISCONNECTED, function(T)  ,  print("\n\tAP - STATION DISCONNECTED".."\n\tMAC: "..T.MAC.."\n\tAID: "..T.AID) ,  end) ,  wifi.eventmon.register(wifi.eventmon.AP_PROBEREQRECVED, function(T)  ,  print("\n\tAP - STATION DISCONNECTED".."\n\tMAC: ".. T.MAC.."\n\tRSSI: "..T.RSSI) ,  end) , "
        seealso = "- [wifi.eventmon.unregister()](#wifieventmonunregister) , - [wifi.sta.eventMonStart()](#wifistaeventmonstart) , - [wifi.sta.eventMonStop()](#wifistaeventmonstop) , - [wifi.sta.eventMonReg()](#wifistaeventmonreg)"
    }
    
    eventmon.unregister = {
        description = "Unregister callbacks for WiFi event monitor."
        syntax = "wifi.eventmon.unregister(Event)"
        parameters = "Event: WiFi event you would like to set a callback for.   , - Valid WiFi events: , 	- wifi.eventmon.STA_CONNECTED   , 	- wifi.eventmon.STA_DISCONNECTED   , 	- wifi.eventmon.STA_AUTHMODE_CHANGE   , 	- wifi.eventmon.STA_GOT_IP   , 	- wifi.eventmon.STA_DHCP_TIMEOUT   , 	- wifi.eventmon.AP_STACONNECTED   , 	- wifi.eventmon.AP_STADISCONNECTED   , 	- wifi.eventmon.AP_PROBEREQRECVED  "
        returns = "nil"
        example = "lua ,  wifi.eventmon.unregister(wifi.eventmon.STA_CONNECTED) , "
        seealso = "- [wifi.eventmon.register()](#wifieventmonregister) , - [wifi.sta.eventMonStart()](#wifistaeventmonstart) , - [wifi.sta.eventMonStop()](#wifistaeventmonstop)"
    }
    
    eventmon.reason = {
        description = "Table containing disconnect reasons. , |  Disconnect reason  |  value  | , |:--------------------|:-------:| , |wifi.eventmon.reason.UNSPECIFIED   |  1  | , |wifi.eventmon.reason.AUTH_EXPIRE   |  2  |				 , |wifi.eventmon.reason.AUTH_LEAVE    |  3  | , |wifi.eventmon.reason.ASSOC_EXPIRE  |  4  | , |wifi.eventmon.reason.ASSOC_TOOMANY |  5  | , |wifi.eventmon.reason.NOT_AUTHED    |  6  | , |wifi.eventmon.reason.NOT_ASSOCED   |  7  | , |wifi.eventmon.reason.ASSOC_LEAVE   |  8  | , |wifi.eventmon.reason.ASSOC_NOT_AUTHED     |  9  | , |wifi.eventmon.reason.DISASSOC_PWRCAP_BAD  |  10  | , |wifi.eventmon.reason.DISASSOC_SUPCHAN_BAD |  11  | , |wifi.eventmon.reason.IE_INVALID    |  13  | , |wifi.eventmon.reason.MIC_FAILURE   |  14  | , |wifi.eventmon.reason.4WAY_HANDSHAKE_TIMEOUT   |  15  | , |wifi.eventmon.reason.GROUP_KEY_UPDATE_TIMEOUT |  16  | , |wifi.eventmon.reason.IE_IN_4WAY_DIFFERS       |  17  | , |wifi.eventmon.reason.GROUP_CIPHER_INVALID     |  18  | , |wifi.eventmon.reason.PAIRWISE_CIPHER_INVALID  |  19  | , |wifi.eventmon.reason.AKMP_INVALID          |  20  | , |wifi.eventmon.reason.UNSUPP_RSN_IE_VERSION |  21  | , |wifi.eventmon.reason.INVALID_RSN_IE_CAP    |  22  | , |wifi.eventmon.reason.802_1X_AUTH_FAILED    |  23  | , |wifi.eventmon.reason.CIPHER_SUITE_REJECTED |  24  | , |wifi.eventmon.reason.BEACON_TIMEOUT    |  200  | , |wifi.eventmon.reason.NO_AP_FOUND       |  201  | , |wifi.eventmon.reason.AUTH_FAIL         |  202  | , |wifi.eventmon.reason.ASSOC_FAIL        |  203  | , |wifi.eventmon.reason.HANDSHAKE_TIMEOUT |  204  |"
    }

}
ws2801 = {
    
    init = {
        description = "Initializes the module and sets the pin configuration."
        syntax = "ws2801.init(pin_clk, pin_data)"
        parameters = "- pin_clk pin for the clock. Supported are GPIO 0, 2, 4, 5. , - pin_data pin for the data. Supported are GPIO 0, 2, 4, 5."
        returns = "nil"
    }
    
    write = {
        description = "Sends a string of RGB Data in 24 bits to WS2801. Don't forget to call ws2801.init() before."
        syntax = "ws2801.write(string)"
        parameters = "- string payload to be sent to one or more WS2801. ,   It should be composed from an RGB triplet per element. ,     - R1 the first pixel's red channel value (0-255) ,     - G1 the first pixel's green channel value (0-255) ,     - B1 the first pixel's blue channel value (0-255)<br /> ,     ... You can connect a lot of WS2801... ,     - R2, G2, B2 are the next WS2801's Red, Green, and Blue channel values"
        returns = "nil"
        example = "lua , ws2801.write(string.char(255,0,0, 0,255,0, 0,0,255)) , "
    }

}
ws2812 = {
    
    init = {
        description = "Initialize UART1 and GPIO2, should be called once and before write()"
        parameters = "none"
        returns = "nil"
    }
    
    write = {
        description = "Send data to a led strip using its native format which is generally Green,Red,Blue for RGB strips , and Green,Red,Blue,White for RGBW strips."
        syntax = "ws2812.write(string)"
        parameters = "- string payload to be sent to one or more WS2812 like leds."
        returns = "nil"
        example = "lua , ws2812.init() , ws2812.write(string.char(255,0,0,255,0,0) -- turn the two first RGB leds to green ,  , lua , ws2812.init() , ws2812.write(string.char(0,0,0,255,0,0,0,255) -- turn the two first RGBW leds to white ,  , ####Buffer module , For more advanced animations, it is useful to keep a "framebuffer" of the strip, , interact with it and flush it to the strip. , For this purpose, the ws2812 library offers a read/write buffer."
        example = "Led chaser with a RGBW strip , lua , local i, b = 0, ws2812.newBuffer(300, 4); b:fill(0,0,0,0); tmr.alarm(0, 50, 1, function() ,         i=i+1 ,         b:fade(2) ,         b:set(i%b:size()+1, 0, 0, 0, 255) ,         b:write() , end)"
    }
    
    newBuffer = {
        description = "Allocate a new memory buffer to store led values."
        syntax = "ws2812.newBuffer(numberOfLeds, bytesPerLed)"
        parameters = " - numberOfLeds length of the led strip ,  - bytesPerLed 3 for RGB strips and 4 for RGBW strips"
        returns = "ws2812.buffer"
    }
    
    buffer:get = {
        description = "Return the value at the given position"
        syntax = "buffer:get(index)"
        parameters = " - index position in the buffer (1 for first led)"
        returns = "(color)"
        example = "lua , buffer:get(2) -- return the color of the second led"
    }
    
    buffer:set = {
        description = "Set the value at the given position"
        syntax = "buffer:set(index, color)"
        parameters = " - index position in the buffer (1 for the first led) ,  - color bytes of the color"
        returns = "nil"
        example = "lua , buffer:set(1, 255, 0, 0) -- set the first led green for a RGB strip"
    }
    
    buffer:size = {
        description = "Return the size of the buffer in number of leds"
        syntax = "buffer:size()"
        parameters = "none"
        returns = "int"
    }
    
    buffer:fill = {
        description = "Fill the buffer with the given color. , The number of given bytes must match the number of bytesPerLed of the buffer"
        syntax = "buffer:fill(color)"
        parameters = " - color bytes of the color"
        returns = "nil"
        example = "lua , buffer:fill(0, 0, 0) -- fill the buffer with black for a RGB strip"
    }
    
    buffer:fade = {
        description = "Divide each byte of each led by the given value. Useful for a fading effect"
        syntax = "buffer:fade(value)"
        parameters = " - value value by which divide each byte"
        returns = "nil"
        example = "lua , buffer:fade(2)"
    }
    
    buffer:write = {
        description = "Output the buffer to the led strip"
        syntax = "buffer:write()"
        parameters = "none"
        returns = "nil"
    }

}
